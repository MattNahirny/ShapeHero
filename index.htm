<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
        <link type="text/css" rel="stylesheet" href="css/style.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
		<script src="https://cdn.firebase.com/js/client/2.2.1/firebase.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    </head>
    <body style="overflow:hidden;">
		<div id="midscreen" style="position:absolute; left: 40px; top:175px;">
		</div>	
		<!--current ===========================================================================-->
		<div id="midscreenSubmit" style="position:absolute; left: 39px; top:200px;">
		</div>	
        <audio id="background_audio" autoplay="autoplay" loop="loop">
            <source src="audio/strike_the_earth.mp3" type="audio/mpeg" />
        </audio>
        <canvas id="canvas" width="320" height="480">
            Your browser does not support the HTML5 canvas tag.
        </canvas>
        <script>
            var ctx = document.getElementById("canvas").getContext("2d"),

            limit = 300,
             lastFrameTimeMs = 0,
             maxFPS = 60,
             delta = 0,
             timestep = 1000 / 60,
             fps = 60,
             framesThisSecond = 0,
             lastFpsUpdate = 0,
             running = false,
             started = false,
             frameID = 0,
             entities = 0,
             mainMenuScreen = false,
             mainMenuOptions = false,
             gameOver = false,
             pause = false,
             portrait = false,
             currentRules = null;
            window.count = 0;
            window.combo = 0;

            ctx.canvas.width = window.innerWidth;
            ctx.canvas.height = window.innerHeight;

            portrait = ctx.canvas.width < ctx.canvas.height;

            var backgroundImg = new Image();
            var backgrounds = ["bright", "galaxy", "lava", "lightning",
                               "fireice", "nebula", "pink", "purple",
                               "purplepink", "paint", "tealpink", "bigstar",
                               "rainbow", "bluemoon", "redspace"];
            var bgimgnum = 0;
            var sf = new ShapeFactory();
            var rs = new RuleSet();
            var df = new Difficulty();
            var updateBuffer = [];
            var layerBuffer = [];



            function notPortrait() {
                stop();
                ctx.rect(0, 0, 320 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                ctx.fillStyle = "rgba(0,0,0,.5)";
                ctx.fill();

                ctx.fillStyle = "red";
                ctx.font = 30 * ctx.canvas.height / 480 + "px Calibri";
                ctx.textAlign = "center";
                ctx.fillText("Please flip your screen to portrait", ctx.canvas.width / 2, ctx.canvas.height / 2);
            }

            function scoreParticle(x, y, score) {
                this.xCurrent = x ;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = 0;
                this.xVelocity = 0;
                this.yVelocity = -0.05 * ctx.canvas.height / 480;
                this.life = 100;
                this.score = score || 0;
                this.clicked = false;
                this.checked = false;
                entities++;

                this.draw = function (interp) {
                    this.life--;
                    ctx.save();
                    ctx.font = "30px Comic Sans MS";
                    ctx.fillStyle = "rgba(255, 0, 0, " + this.life / 100 + ")";
                    ctx.textAlign = "center";
                    ctx.fillText(this.score, this.xCurrent, this.yCurrent);
                    ctx.restore();
                }
                this.update = function () {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }
                this.offScreen = function () {
                    return this.life <= 0;
                }
                this.contains = function (mx, my) {
                    return false;
                }
            }

            function explosion(x, y, size) {
                var explosionParticles = [];
                for (var i = 0; i < size; i++) {
                    explosionParticles.push(new particle(x, y, (Math.random() - 0.5) / 10, (Math.random() - 0.5) / 10));
                }

                this.draw = function (interp) {
                    for (var i = 0; i < explosionParticles.length; i++) {
                        explosionParticles[i].draw(interp);
                    }
                }

                this.update = function () {
                    for (var i = 0; i < explosionParticles.length; i++) {
                        explosionParticles[i].update();
                    }
                }

                this.offScreen = function () {
                    for (var i = 0; i < explosionParticles.length; i++) {
                        explosionParticles[i].offScreen();
                    }
                }

                this.contains = function (mx, my) {
                    return false;
                }
            }

            function particle(x, y, xVelocity, yVelocity) {
                this.xCurrent = x ;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = 0;
                this.xVelocity = xVelocity * ctx.canvas.width / 320;
                this.yVelocity = yVelocity * ctx.canvas.height / 480;
                this.xAcceleration = 0;
                this.yAcceleration = 0.0001;

                this.update = function () {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xVelocity += this.xAcceleration * delta;
                    this.yVelocity += this.yAcceleration * delta;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }

                this.draw = function (interp) {
                    ctx.save();
                    ctx.fillStyle = "yellow";
                    ctx.fillRect(this.xPrevious + (this.xCurrent - this.xPrevious) * interp, this.yPrevious + (this.yCurrent - this.yPrevious) * interp, 5 * ctx.canvas.width / 320, 5 * ctx.canvas.height / 480)
                    ctx.restore();
                }

                this.offScreen = function () {
                    return this.yCurrent >= canvas.height;
                }

                this.contains = function (mx, my) {
                    return false;
                }
            }

            window.addEventListener("resize", function () {
                ctx.canvas.width = window.innerWidth;
                ctx.canvas.height = window.innerHeight;
                if (mainMenuOptions) {
                    mainMenu();
                    optionsScreen();
                } else if (mainMenuScreen) {
                    mainMenu();
                } else if (pause) {
                    draw(delta / timestep);
                    pauseScreen();
                } else {
                    draw(delta / timestep);
                }
                /*portrait = ctx.canvas.width < ctx.canvas.height;
                if(!portrait) {
                notPortrait();
                return;
                } 
                start();*/
            });

            //---------------------------------------
            //Constructor for a Circle
            //---------------------------------------
            function Circle(x, y, z, xVelocity, yVelocity, colour) {
                var randomColour = ["red", "blue", "green", "yellow"];
                var bodyImg = new Image();
                this.shapeType = "Circle";
                this.xCurrent = x ;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = z || 0;
                this.xVelocity = xVelocity || 0;
                this.yVelocity = yVelocity || 0.1 * ctx.canvas.height / 480;
                this.clicked = false;
                this.checked = false;
                entities++;
                if (colour == "random") {
                    this.colour = randomColour[Math.floor(Math.random() * 4)];
                } else {
                    this.colour = colour || randomColour[Math.floor(Math.random() * 4)];
                }

                if (this.colour == "red") {
                    bodyImg.src = "img/shapes/circle/red_circle.png";
                } else if (this.colour == "blue") {
                    bodyImg.src = "img/shapes/circle/blue_circle.png";
                } else if (this.colour == "green") {
                    bodyImg.src = "img/shapes/circle/green_circle.png";
                } else if (this.colour == "yellow") {
                    bodyImg.src = "img/shapes/circle/yellow_circle.png";
                }

                this.draw = function (interp) {
                    ctx.drawImage(bodyImg, this.xPrevious + (this.xCurrent - this.xPrevious) * interp, this.yPrevious + (this.yCurrent - this.yPrevious) * interp, 64 * ctx.canvas.width / 320, 64 * ctx.canvas.height / 480);
                }
                this.update = function () {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }
                this.offScreen = function () {
                    return this.xCurrent >= canvas.width || this.yCurrent >= canvas.height;
                }

                this.contains = function (mx, my) {
                    // All we have to do is make sure the Mouse X,Y fall in the area between
                    // the shape's X and (X + Width) and its Y and (Y + Height)
                    return (this.xCurrent <= mx) && (this.xCurrent + 64 * ctx.canvas.width / 320 >= mx) &&
                         (this.yCurrent <= my) && (this.yCurrent + 64 * ctx.canvas.height / 480 >= my);
                }
            }

            //---------------------------------------
            //Constructor for a Square
            //---------------------------------------
            function Square(x, y, z, xVelocity, yVelocity, colour) {
                var randomColour = ["red", "blue", "green", "yellow"];
                var bodyImg = new Image();
                this.shapeType = "Square";
                this.xCurrent = x ;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = z || 0;
                this.xVelocity = xVelocity || 0;
                this.yVelocity = yVelocity || 0.1 * ctx.canvas.height / 480;
                this.clicked = false;
                this.checked = false;
                entities++;
                if (colour == "random") {
                    this.colour = randomColour[Math.floor(Math.random() * 4)];
                } else {
                    this.colour = colour || randomColour[Math.floor(Math.random() * 4)];
                }

                if (this.colour == "red") {
                    bodyImg.src = "img/shapes/square/red_square.png";
                } else if (this.colour == "blue") {
                    bodyImg.src = "img/shapes/square/blue_square.png";
                } else if (this.colour == "green") {
                    bodyImg.src = "img/shapes/square/green_square.png";
                } else if (this.colour == "yellow") {
                    bodyImg.src = "img/shapes/square/yellow_square.png";
                }

                this.draw = function (interp) {
                    ctx.drawImage(bodyImg, this.xPrevious + (this.xCurrent - this.xPrevious) * interp, this.yPrevious + (this.yCurrent - this.yPrevious) * interp, 64 * ctx.canvas.width / 320, 64 * ctx.canvas.height / 480);
                }
                this.update = function () {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }
                this.offScreen = function () {
                    return this.xCurrent >= canvas.width || this.yCurrent >= canvas.height;
                }
                this.contains = function (mx, my) {
                    // All we have to do is make sure the Mouse X,Y fall in the area between
                    // the shape's X and (X + Width) and its Y and (Y + Height)
                    return (this.xCurrent <= mx) && (this.xCurrent + 64 * ctx.canvas.width / 320 >= mx) &&
                         (this.yCurrent <= my) && (this.yCurrent + 64 * ctx.canvas.height / 480 >= my);
                }
            }

            //---------------------------------------
            //Constructor for a Triangle
            //---------------------------------------
            function Triangle(x, y, z, xVelocity, yVelocity, colour) {
                var randomColour = ["red", "blue", "green", "yellow"];
                var bodyImg = new Image();
                this.shapeType = "Triangle";
                this.xCurrent = x ;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = z || 0;
                this.xVelocity = xVelocity || 0;
                this.yVelocity = yVelocity || 0.1 * ctx.canvas.height / 480;
                this.clicked = false;
                this.checked = false;
                entities++;

                if (colour == "random") {
                    this.colour = randomColour[Math.floor(Math.random() * 4)];
                } else {
                    this.colour = colour || randomColour[Math.floor(Math.random() * 4)];
                }

                if (this.colour == "red") {
                    bodyImg.src = "img/shapes/triangle/red_triangle.png";
                } else if (this.colour == "blue") {
                    bodyImg.src = "img/shapes/triangle/blue_triangle.png";
                } else if (this.colour == "green") {
                    bodyImg.src = "img/shapes/triangle/green_triangle.png";
                } else if (this.colour == "yellow") {
                    bodyImg.src = "img/shapes/triangle/yellow_triangle.png";
                }

                this.draw = function (interp) {
                    ctx.drawImage(bodyImg, this.xPrevious + (this.xCurrent - this.xPrevious) * interp, this.yPrevious + (this.yCurrent - this.yPrevious) * interp, 64 * ctx.canvas.width / 320, 64 * ctx.canvas.height / 480);
                }
                this.update = function () {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }
                this.offScreen = function () {
                    return this.xCurrent >= canvas.width || this.yCurrent >= canvas.height;
                }
                this.contains = function (mx, my) {
                    // All we have to do is make sure the Mouse X,Y fall in the area between
                    // the shape's X and (X + Width) and its Y and (Y + Height)
                    return (this.xCurrent <= mx) && (this.xCurrent + 64 * ctx.canvas.width / 320 >= mx) &&
                         (this.yCurrent <= my) && (this.yCurrent + 64 * ctx.canvas.height / 480 >= my);
                }

            }

            //---------------------------------------
            //Constructor for a Star
            //---------------------------------------
            function Star(x, y, z, xVelocity, yVelocity) {
                var bodyImg = new Image();
                this.shapeType = "Star";
                this.colour = "yellow";
                bodyImg.src = "img/shapes/star/star.png";
                this.xCurrent = x ;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = z || 0;
                this.xVelocity = xVelocity || 0;
                this.yVelocity = yVelocity || 0.1 * ctx.canvas.height / 480;
                this.clicked = false;
                this.checked = false;
                entities++;
                this.draw = function (interp) {
                    ctx.drawImage(bodyImg, this.xPrevious + (this.xCurrent - this.xPrevious) * interp, this.yPrevious + (this.yCurrent - this.yPrevious) * interp, 64 * ctx.canvas.width / 320, 64 * ctx.canvas.height / 480);
                }
                this.update = function () {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }
                this.offScreen = function () {
                    return this.xCurrent >= canvas.width || this.yCurrent >= canvas.height;
                }
                this.contains = function (mx, my) {
                    // All we have to do is make sure the Mouse X,Y fall in the area between
                    // the shape's X and (X + Width) and its Y and (Y + Height)
                    return (this.xCurrent <= mx) && (this.xCurrent + 64 * ctx.canvas.width / 320 >= mx) &&
                         (this.yCurrent <= my) && (this.yCurrent + 64 * ctx.canvas.height / 480 >= my);
                }
            }

            //The way that the factory works is you call createShape() with a parameter
            //the parameter is a string of which shape to be created or random
            //eg. ShapeFactory.createShape("blueCircle");
            //or 
            //ShapeFactory.createShape("random");
            function ShapeFactory() { }

            //---------------------
            //spawnCheck method
            //---------------------
            ShapeFactory.prototype.spawnCheck = function spawnCheck(shape) {
                var spawnBox = 0;
                if (shape.yCurrent > spawnBox) {
                    shape.checked = true;
                    return true;
                } else {
                    return false;
                }
            };
            //---------------------
            //createShape method
            //---------------------
            ShapeFactory.prototype.createShape = function createShape(type) {
                var randomShape = ["Circle", "Square", "Triangle"];
                var lane = [0, 64 * canvas.width / 320, 128 * canvas.width / 320, 192 * canvas.width / 320, 256 * canvas.width / 320];
                if (type == "circle") {
                    return new Circle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "random");
                } else if (type == "square") {
                    return new Square(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "random");
                } else if (type == "triangle") {
                    return new Triangle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "random");
                } else if (type == "redCircle") {
                    return new Circle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "red");
                } else if (type == "blueCircle") {
                    return new Circle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "blue");
                } else if (type == "greenCircle") {
                    return new Circle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "green");
                } else if (type == "yellowCircle") {
                    return new Circle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "yellow");
                } else if (type == "redSquare") {
                    return new Square(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "red");
                } else if (type == "blueSquare") {
                    return new Square(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "blue");
                } else if (type == "greenSquare") {
                    return new Square(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "green");
                } else if (type == "yellowSquare") {
                    return new Square(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "yellow");
                } else if (type == "redTriangle") {
                    return new Triangle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "red");
                } else if (type == "blueTriangle") {
                    return new Triangle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "blue");
                } else if (type == "greenTriangle") {
                    return new Triangle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "green");
                } else if (type == "yellowTriangle") {
                    return new Triangle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "yellow");
                } else if (type == "star") {
                    return new Star(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity());
                } else if (type == "random") {
                    var rs = randomShape[Math.floor(Math.random() * 3)];

                    if (rs == "Circle") {
                        return new Circle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "random");
                    } else if (rs == "Square") {
                        return new Square(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "random");
                    } else if (rs == "Triangle") {
                        return new Triangle(lane[Math.floor(Math.random() * 5)], -64 * ctx.canvas.height / 480, null, null, df.getVelocity(), "random");
                    }
                }
                return;
            };
            //--------------------------------------------
            //Rule Logic
            //--------------------------------------------
            function Rule(type) {
                this.type = type;
                this.ruleImg = new Image();
                this.ruleImg.src = "img/rules/" + type + ".png";
                if (type === "red" ||
                    type === "blue" ||
                    type === "green" ||
                    type === "yellow" ||
                    type === "nored" ||
                    type === "noblue" ||
                    type === "nogreen" ||
                    type === "noyellow") {
                    this.genre = "colour";
                } else {
                    this.genre = "shape";
                }


                Rule.prototype.toString = function ruleToString() {
                    var ret = this.type + "\n";
                    return ret;
                };
            }

            function RuleSet() {
                this.rules = [];
                this.ruleNum = 1;
                this.availableRules = ["red", "blue", "green", "yellow", "Circle", "Square", "Triangle",
                                       "nored", "noblue", "nogreen", "noyellow", "noCircle", "noSquare", "noTriangle"];

                RuleSet.prototype.getRuleImg = function getRuleImg(n) {
                    return this.rules[n].ruleImg;
                };

                RuleSet.prototype.newRule = function newRule() {
                    var rand;

                    if (this.ruleNum === 1) {
                        rand = Math.floor(Math.random() * this.availableRules.length);
                        this.rules.push(new Rule(this.availableRules[rand]));
                        if (rand < 7) {
                            this.availableRules.splice(7, 7);
                        } else {
                            this.availableRules.splice(0, 7);
                        }
                        this.ruleNum++;
                    } else if (this.ruleNum === 2) {
                        if (this.rules[0].genre === "shape") {
                            rand = Math.floor(Math.random() * 4);
                        } else {
                            rand = Math.floor(Math.random() * ((5 - 3) + 1) + 3);
                        }
                        this.rules.push(new Rule(this.availableRules[rand]));
                        this.ruleNum++;
                    } else {
                        rand = Math.floor(Math.random() * this.availableRules.length);
                        this.rules.push(new Rule(this.availableRules[rand]));
                    }
                    this.availableRules.splice(rand % this.availableRules.length, 1);
                };
            }

            //------------------------
            //Difficulty
            //------------------------
            function Difficulty() {
                this.level = 1;
                this.targetScore = 20;
                this.numShapes = 1;
                this.levelChangePeriod = false;
                this.newGamePeriod = true;

                Difficulty.prototype.levelProgress = function levelProgress(score) {
                    if (score > this.targetScore) {
                        this.level++;


                        for (var i = (this.level - 1) * 20; i < this.level * 20; i++) {
                            this.targetScore += 0.6 * Math.log2(i);
                        }
                    } else {
                        gameOver = true;
                    }
                    if (bgimgnum < 14) {
                        bgimgnum++;
                    } else {
                        bgimgnum = 0;
                    }
                    backgroundImg.src = "img/backgrounds/" + backgrounds[bgimgnum] + "_background.png";
                };

                Difficulty.prototype.getVelocity = function getVelocity() {
                    return (0.03 + Math.min(this.level * 0.01, 0.13)) * ctx.canvas.height / 480;
                };

                Difficulty.prototype.checkLevelChange = function checkLevelChange() {
                    if (this.numShapes === this.level * 20) {
                        return true;
                    } else {
                        return false;
                    }
                };

            }

            canvas.addEventListener('mousedown', function (e) {
                var mouse = getMouse(e);
                var mx = mouse.x;
                var my = mouse.y;
                var l = updateBuffer.length;

                //LOL
                /*if (portrait === false || true) {
                } else*/

                if (mainMenuOptions === true) {
                    if (mx >= 280 * ctx.canvas.width / 320 && mx <= 310 * ctx.canvas.width / 320 && my >= 60 * ctx.canvas.height / 480 && my <= 90 * ctx.canvas.height / 480) {
                        mainMenuOptions = false;
                        mainMenu();
                    } else if (mx >= 30 * ctx.canvas.width / 320 && mx <= 65 * ctx.canvas.width / 320 && my >= 110 * ctx.canvas.height / 480 && my <= 145 * ctx.canvas.height / 480) {
                        toggleBGM();
                        if (bgm.muted === false) {
                            ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 110 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        } else {
                            ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 110 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        }
                    } else if (mx >= 30 * ctx.canvas.width / 320 && mx <= 65 * ctx.canvas.width / 320 && my >= 150 * ctx.canvas.height / 480 && my <= 185 * ctx.canvas.height / 480) {
                        toggleSFX();
                        if (sfx === true) {
                            ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 150 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        } else {
                            ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 150 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        }
                    } else if (mx >= 30 * ctx.canvas.width / 320 && mx <= 65 * ctx.canvas.width / 320 && my >= 190 * ctx.canvas.height / 480 && my <= 225 * ctx.canvas.height / 480) {
                        fullScreen();
                        if (fs === true) {
                            ctx.drawImage(restoreButtonImg, 30 * ctx.canvas.width / 320, 190 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        } else {
                            ctx.drawImage(fullscreenButtonImg, 30 * ctx.canvas.width / 320, 190 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        }
                    }
                } else if (mainMenuScreen === true) {
                    if (mx >= 28 * ctx.canvas.width / 320 && mx <= 292 * ctx.canvas.width / 320 && my >= 240 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        newGame();
                    } else if (mx >= 28 * ctx.canvas.width / 320 && mx <= 292 * ctx.canvas.width / 320 && my >= 320 * ctx.canvas.height / 480 && my <= 374 * ctx.canvas.height / 480) {
                        leaderboardScreen();
                    } else if (mx >= 28 * ctx.canvas.width / 320 && mx <= 292 * ctx.canvas.width / 320 && my >= 400 * ctx.canvas.height / 480 && my <= 454 * ctx.canvas.height / 480) {
                        optionsScreen();
                    }
                } else if (gameOver === true) {
                    if (mx >= 20 * ctx.canvas.width / 320 && mx <= 159 * ctx.canvas.width / 320 && my >= 250 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        if (document.getElementById("nameInput") != null) {
                            document.getElementById("midscreen").removeChild(textFieldHS);
                            document.getElementById("midscreenSubmit").removeChild(submitHS);
                        }
                        mainMenu();
                    } else if (mx >= 160 * ctx.canvas.width / 320 && mx <= 300 * ctx.canvas.width / 320 && my >= 250 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        if (document.getElementById("nameInput") != null) {
                            document.getElementById("midscreen").removeChild(textFieldHS);
                            document.getElementById("midscreenSubmit").removeChild(submitHS);
                        }
                        newGame();
                    }
                } else if (pause === true) {
                    if (mx >= 280 * ctx.canvas.width / 320 && mx <= 310 * ctx.canvas.width / 320 && my >= 60 * ctx.canvas.height / 480 && my <= 90 * ctx.canvas.height / 480) {
                        pause = false;
                        start();
                    } else if (mx >= 30 * ctx.canvas.width / 320 && mx <= 65 * ctx.canvas.width / 320 && my >= 170 * ctx.canvas.height / 480 && my <= 205 * ctx.canvas.height / 480) {
                        toggleBGM();
                        if (bgm.muted === false) {
                            ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 170 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        } else {
                            ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 170 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        }
                    } else if (mx >= 30 * ctx.canvas.width / 320 && mx <= 65 * ctx.canvas.width / 320 && my >= 210 * ctx.canvas.height / 480 && my <= 245 * ctx.canvas.height / 480) {
                        toggleSFX();
                        if (sfx === true) {
                            ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 210 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        } else {
                            ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 210 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        }
                    } else if (mx >= 20 * ctx.canvas.width / 320 && mx <= 159 * ctx.canvas.width / 320 && my >= 250 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        mainMenu();
                    } else if (mx >= 160 * ctx.canvas.width / 320 && mx <= 300 * ctx.canvas.width / 320 && my >= 250 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        newGame();
                    }
                } else if (pause === false && mx >= 290 * ctx.canvas.width / 320 && my <= 30 * ctx.canvas.height / 480) {
                    pauseScreen();
                } else if (pause === false) {
                    for (var i = 0; i < l; i++) {
                        if (updateBuffer[i].contains(mx, my)) {
                            updateBuffer[i].clicked = true;
                            return;
                        }
                    }
                }
            }, true);

            canvas.addEventListener('mouseup', function (e) { }, true);

            /*TODO WTF?
            Shape.prototype.hit = function(mouse) {
            mx = getMouse(mouse).x;
            my = getMouse(mouse).y;
            ctx.fillText("x: " + x, 180, 480);
            ctx.fillText("y: " + entities, 180, 480);
            }*/

            getMouse = function (mouseEvent) {
                var element = this.canvas, offsetX = 0, offsetY = 0, mx, my;
                if (element.offsetParent !== undefined) {
                    do {
                        offsetX += element.offsetLeft;
                        offsetY += element.offsetTop;
                    } while ((element = element.offsetParent));
                }
                //offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;
                //offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;
                mx = mouseEvent.pageX; // - offsetX;
                my = mouseEvent.pageY; // - offsetY;
                return { x: mx, y: my };
            }

            //------------------------------------------
            //UPDATE BUFFER
            //------------------------------------------
            function update(delta) {
                var l = updateBuffer.length,
                 s = 0;
                if (df.checkLevelChange() === true) {
                    df.levelChangePeriod = true;
                    df.levelProgress(window.count);

                }
                if (entities === 0) {
                    if (df.level > 1 && df.level % 10 === 0) {
                        currentRules = new RuleSet();
                        currentRules.newRule();
                        df.levelChangePeriod = false;
                        updateBuffer.push(sf.createShape("random"));
                    } else if (df.levelChangePeriod === true && df.level === 2 ||
                                                         df.level === 3 ||
                                                         df.level % 11 === 0 ||
                                                         df.level % 12 === 0) {
                        currentRules.newRule();
                        df.levelChangePeriod = false;
                        updateBuffer.push(sf.createShape("random"));
                    } else {
                        df.levelChangePeriod = false
                        updateBuffer.push(sf.createShape("random"));
                    }
                }

                for (var i = 0; i < l; i++) {

                    //lull period when game starts and when level changes
                    if (df.levelChangePeriod === false && df.newGamePeriod === false) {
                        //if its a shape do a spawnCheck and if it passes spawn a shape
                        if (updateBuffer[i - s] instanceof Circle ||
                            updateBuffer[i - s] instanceof Square ||
                            updateBuffer[i - s] instanceof Triangle ||
                            updateBuffer[i - s] instanceof Star) {
                            if (updateBuffer[i - s].checked === false &&
                                sf.spawnCheck(updateBuffer[i - s]) === true) {
                                updateBuffer.push(sf.createShape("random"));
                                df.numShapes++;
                            }
                        }
                    }

                    if (updateBuffer[i - s].offScreen()) {
                        if (updateBuffer[i - s] instanceof scoreParticle) {

                        } else if (currentRules.rules[0].type.slice(0, 2) === "no") {
                            //negative rules: on offscreen, pass any = pass
                            var rulesetPassed = false;
                            for (var j = 0; j < currentRules.rules.length; j++) {
                                if (currentRules.rules[j].type === "no" + updateBuffer[i - s].shapeType || currentRules.rules[j].type === "no" + updateBuffer[i - s].colour) {
                                    rulesetPassed = true;
                                    rulePass();
                                    break;
                                }
                            }
                            if (rulesetPassed === false) {
                                ruleFail();
                            }
                        } else {
                            //positive rules: on offscreen, fail any = fail
                            var rulesetFailed = false;
                            for (var j = 0; j < currentRules.rules.length; j++) {
                                if (currentRules.rules[j].type === updateBuffer[i - s].shapeType || currentRules.rules[j].type === updateBuffer[i - s].colour) {
                                    rulesetFailed = true;
                                    ruleFail();
                                    break;
                                }
                            }
                            if (rulesetFailed === false) {
                                rulePass();
                            }
                        }

                        updateBuffer.splice(i - s, 1);
                        s++;
                        entities--;
                    } else if (updateBuffer[i - s].clicked === true) {
                        if (currentRules.rules[0].type.slice(0, 2) === "no") {
                            //negative rules: on click, fail any rule = fail
                            var rulesetFailed = false;
                            for (var j = 0; j < currentRules.rules.length; j++) {
                                if (currentRules.rules[j].type === "no" + updateBuffer[i - s].shapeType || currentRules.rules[j].type === "no" + updateBuffer[i - s].colour) {
                                    rulesetFailed = true;
                                    ruleFail();
                                    break;
                                }
                            }
                            if (rulesetFailed === false) {
                                rulePass();
                                updateBuffer.push(new scoreParticle(updateBuffer[i - s].xCurrent + 32 * ctx.canvas.width / 320, updateBuffer[i - s].yCurrent + 32 * ctx.canvas.height / 480, window.combo));
                                updateBuffer.push(new explosion(updateBuffer[i - s].xCurrent + 32 * ctx.canvas.width / 320, updateBuffer[i - s].yCurrent + 32 * ctx.canvas.height / 480, 5));
                            }
                        } else {
                            //positive rules: on click, pass any rule = pass
                            var rulesetPassed = false;
                            for (var j = 0; j < currentRules.rules.length; j++) {
                                if (currentRules.rules[j].type === updateBuffer[i - s].shapeType || currentRules.rules[j].type === updateBuffer[i - s].colour) {
                                    rulesetPassed = true;
                                    rulePass();
                                    updateBuffer.push(new scoreParticle(updateBuffer[i - s].xCurrent + 32 * ctx.canvas.width / 320, updateBuffer[i - s].yCurrent + 32 * ctx.canvas.height / 480, window.combo));
                                    updateBuffer.push(new explosion(updateBuffer[i - s].xCurrent + 32 * ctx.canvas.width / 320, updateBuffer[i - s].yCurrent + 32 * ctx.canvas.height / 480, 5));
                                    break;
                                }
                            }
                            if (rulesetPassed === false) {
                                ruleFail();
                            }
                        }

                        updateBuffer.splice(i - s, 1);
                        s++;
                        entities--;
                    } else {
                        updateBuffer[i - s].update(delta);
                        layerBuffer.push(updateBuffer[i - s]);
                    }
                }
                layerBuffer.sort(function (a, b) {
                    return b.layer - a.layer;
                });
            }

            function rulePass() {
                if (window.combo === 0) {
                    window.count += ++window.combo;
                } else {
                    window.count += Math.ceil(Math.log2(++window.combo));
                }
                validSFX();
            }

            function ruleFail() {
                window.combo = 0;
                errorSFX();
            }

            //----------------------------------------------------------
            //Draw
            //----------------------------------------------------------
            function draw(interp) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                //-----------------------
                //Game Screen
                //-----------------------


                ctx.drawImage(backgroundImg, 0, 0, 320 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);

                ctx.strokeStyle = "grey";
                ctx.lineWidth = "2";
                ctx.beginPath();
                ctx.moveTo(64 * ctx.canvas.width / 320, 0);
                ctx.lineTo(64 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(128 * ctx.canvas.width / 320, 0);
                ctx.lineTo(128 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(192 * ctx.canvas.width / 320, 0);
                ctx.lineTo(192 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(256 * ctx.canvas.width / 320, 0);
                ctx.lineTo(256 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                ctx.stroke();

                var l = layerBuffer.length;
                for (var i = 0; i < l; i++) {
                    layerBuffer[i].draw(interp);
                }
                layerBuffer = [];
                ctx.fillStyle = "white";
                ctx.fillText("FPS: " + Math.round(fps), 180 * ctx.canvas.width / 320, 410 * ctx.canvas.height / 480);
                //ctx.fillText("Entities: " + entities,180,440);

                // ** Add stuff you want drawn on top all the time here **
                //----------------
                //Top Bar
                //----------------
                ctx.rect(0, 0, 320 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                var grd = ctx.createLinearGradient(0, 0, 0, 35 * ctx.canvas.height / 480);
                grd.addColorStop(0, "grey");
                grd.addColorStop(0.2, "lightgrey");
                grd.addColorStop(0.8, "lightgrey");
                grd.addColorStop(1, "grey");
                ctx.fillStyle = grd;
                ctx.fill();

                ctx.strokeStyle = "black";
                ctx.beginPath();
                ctx.moveTo(0, 35 * ctx.canvas.height / 480);
                ctx.lineTo(320 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                ctx.stroke();

                ctx.fillStyle = "black";
                ctx.font = 30 * ctx.canvas.height / 480 + "px Calibri";
                ctx.fillText("Score: " + window.count, 0, 30 * ctx.canvas.height / 480);

                ctx.textAlign = "end";
                if (window.combo <= 1) {
                    ctx.fillText(window.combo + "x", 280 * ctx.canvas.width / 320, 30 * ctx.canvas.height / 480);
                } else {
                    ctx.fillText(Math.ceil(Math.log2(window.combo)) + "x", 280 * ctx.canvas.width / 320, 30 * ctx.canvas.height / 480);
                }
                ctx.textAlign = "start";


                ctx.drawImage(pauseButtonImg, 285 * ctx.canvas.width / 320, 0, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);


                //------------------
                //Bottom Bar
                //------------------
                ctx.rect(0, 445 * ctx.canvas.height / 480, 320 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                var grd = ctx.createLinearGradient(0, 445 * ctx.canvas.height / 480, 0, 480 * ctx.canvas.height / 480);
                grd.addColorStop(0, "grey");
                grd.addColorStop(0.2, "lightgrey");
                grd.addColorStop(0.8, "lightgrey");
                grd.addColorStop(1, "grey");
                ctx.fillStyle = grd;
                ctx.fill();

                ctx.beginPath();
                ctx.rect(0, 445 * ctx.canvas.height / 480, window.count / df.targetScore * ctx.canvas.width, 480 * ctx.canvas.height / 480);
                ctx.fillStyle = "rgba(150,0,150,.5)";
                ctx.fill();

                ctx.strokeStyle = "black";
                ctx.beginPath();
                ctx.moveTo(0, 445 * ctx.canvas.height / 480);
                ctx.lineTo(320 * ctx.canvas.width / 320, 445 * ctx.canvas.height / 480);
                ctx.stroke();

                ctx.fillStyle = "black";
                ctx.font = 30 * ctx.canvas.height / 480 + "px Calibri";
                ctx.fillText("Rules:", 0, 475 * ctx.canvas.height / 480);
                ctx.drawImage(currentRules.getRuleImg(0), 90 * ctx.canvas.width / 320, 445 * ctx.canvas.height / 480, 90 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                if (currentRules.rules.length > 1) {
                    ctx.drawImage(currentRules.getRuleImg(1), 160 * ctx.canvas.width / 320, 445 * ctx.canvas.height / 480, 90 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }
                if (currentRules.rules.length > 2) {
                    ctx.drawImage(currentRules.getRuleImg(2), 230 * ctx.canvas.width / 320, 445 * ctx.canvas.height / 480, 90 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }
            }

            function panic() {
                delta = 0;
                ctx.fillText("Panic", 100 * ctx.canvas.width / 320, 200 * ctx.canvas.height / 480);
            }

            //function begin() {
            //}

            function end(fps) {
                /*if (fps < 25) {
                entities = 0;
                updateBuffer = [];
                }*/
            }

            function stop() {
                running = false;
                started = false;
                cancelAnimationFrame(frameID);
            }

            function start() {
                if (!started) {
                    started = true;
                    frameID = requestAnimationFrame(function (timestamp) {
                        draw(1);
                        running = true;
                        lastFrameTimeMs = timestamp;
                        lastFpsUpdate = timestamp;
                        framesThisSecond = 0;
                        frameID = requestAnimationFrame(mainLoop);
                    });
                }
            }

            function mainLoop(timestamp) {
                // Throttle the frame rate.    
                if (timestamp < lastFrameTimeMs + (1000 / maxFPS)) {
                    frameID = requestAnimationFrame(mainLoop);
                    return;
                }
                delta += timestamp - lastFrameTimeMs;
                lastFrameTimeMs = timestamp;

                //begin(timestamp, delta);

                if (timestamp > lastFpsUpdate + 1000) {
                    fps = 0.25 * framesThisSecond + 0.75 * fps;

                    lastFpsUpdate = timestamp;
                    framesThisSecond = 0;
                }
                framesThisSecond++;

                var numUpdateSteps = 0;
                while (delta >= timestep) {
                    update(timestep);
                    delta -= timestep;
                    if (++numUpdateSteps >= 240) {
                        panic();
                        break;
                    }
                }

                draw(delta / timestep);

                end(fps);

                frameID = requestAnimationFrame(mainLoop);

                if (gameOver === true) {
                    gameOverScreen();
                }
            }

            window.onload = function () {
                mainMenu();
                //breaks
                /*if(!portrait) {
                notPortrait();
                }*/
            };

            //------------------------
            //Images load
            //------------------------
            var backgroundImage = new Image();
            backgroundImage.src = "img/backgrounds/star_background.png";
            var logo = new Image();
            logo.src = "img/logo.png";
            var playButton = new Image();
            playButton.src = "img/buttons/play_button.png";
            var leaderboardButton = new Image();
            leaderboardButton.src = "img/buttons/leaderboard_button.png";
            var optionsButton = new Image();
            optionsButton.src = "img/buttons/options_button.png";
            var menuButtonImg = new Image();
            menuButtonImg.src = "img/buttons/mainmenu_button.png";
            var restartButtonImg = new Image();
            restartButtonImg.src = "img/buttons/restart_button.png";
            var closeButtonImg = new Image();
            closeButtonImg.src = "img/buttons/close_button.png";
            var speakerImg = new Image();
            speakerImg.src = "img/buttons/speaker_button.png";
            var muteImg = new Image();
            muteImg.src = "img/buttons/mute_button.png";
            var submitImg = new Image();
            submitImg.src = "img/buttons/submit_button.png";
            var pauseButtonImg = new Image();
            pauseButtonImg.src = "img/buttons/pause_button.png";
            var fullscreenButtonImg = new Image();
            fullscreenButtonImg.src = "img/buttons/fullscreen_button.png";
            var restoreButtonImg = new Image();
            restoreButtonImg.src = "img/buttons/restore_button.png";

            //---------------------------
            //Pause menu drawing
            //---------------------------
            function pauseScreen() {
                pause = true;
                stop();

                ctx.rect(0, 35 * ctx.canvas.height / 480, 320 * ctx.canvas.width / 320, 410 * ctx.canvas.height / 480);
                ctx.fillStyle = "rgba(0,0,0,.5)";
                ctx.fill();

                ctx.beginPath();
                ctx.lineWidth = "4";
                ctx.strokeStyle = "black";
                ctx.rect(22 * ctx.canvas.width / 320, 70 * ctx.canvas.height / 480, 276 * ctx.canvas.width / 320, 190 * ctx.canvas.height / 480);
                ctx.stroke();

                var grd = ctx.createLinearGradient(0, 70 * ctx.canvas.height / 480, 0, 260 * ctx.canvas.height / 480);
                grd.addColorStop(0, "grey");
                grd.addColorStop(0.2, "lightgrey");
                grd.addColorStop(0.8, "lightgrey");
                grd.addColorStop(1, "grey");
                ctx.fillStyle = grd;
                ctx.fill();

                ctx.fillStyle = "black";
                ctx.font = 20 * ctx.canvas.height / 480 + "px Calibri";
                ctx.fillText("Current Rule: ", 25 * ctx.canvas.width / 320, 90 * ctx.canvas.height / 480);

                ctx.beginPath();
                ctx.lineWidth = "2";
                ctx.moveTo(30 * ctx.canvas.width / 320, 125 * ctx.canvas.height / 480);
                ctx.lineTo(290 * ctx.canvas.width / 320, 125 * ctx.canvas.height / 480);
                ctx.stroke();

                ctx.fillText("Background Music", 70 * ctx.canvas.width / 320, 195 * ctx.canvas.height / 480);
                ctx.fillText("Sound Effects", 70 * ctx.canvas.width / 320, 235 * ctx.canvas.height / 480);
                ctx.fillText("Fullscreen", 70 * ctx.canvas.width / 320, 275 * ctx.canvas.height / 480);

                if (bgm.muted === false) {
                    ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 170 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                } else {
                    ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 170 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }

                if (sfx === true) {
                    ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 210 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                } else {
                    ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 210 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }

                ctx.drawImage(menuButtonImg, 20 * ctx.canvas.width / 320, 250 * ctx.canvas.height / 480, 140 * ctx.canvas.width / 320, 44 * ctx.canvas.height / 480);
                ctx.drawImage(restartButtonImg, 160 * ctx.canvas.width / 320, 250 * ctx.canvas.height / 480, 140 * ctx.canvas.width / 320, 44 * ctx.canvas.height / 480);
                ctx.drawImage(closeButtonImg, 280 * ctx.canvas.width / 320, 60 * ctx.canvas.height / 480, 30 * ctx.canvas.width / 320, 30 * ctx.canvas.height / 480);
            }

            //-------------------------------------------
            //BGM toggle variable and function
            //-------------------------------------------
            var bgm = document.getElementById('background_audio');
            bgm.muted = true;
            function toggleBGM() {
                bgm.muted = !bgm.muted;
            }

            //-------------------------------------------------------
            //SFX toggle function, don't play sounds if false.
            //-------------------------------------------------------
            var sfx = false;
            function toggleSFX() {
                sfx = !sfx;
            }

            //--------------------
            //Valid SFX
            //--------------------
            function validSFX() {
                if (sfx === true) {
                    var new_sfx = new Audio('audio/valid.mp3');
                    new_sfx.play();
                }
            }

            //-------------------
            //Error SFX
            //-------------------
            function errorSFX() {
                if (sfx === true) {
                    var new_sfx = new Audio('audio/error.mp3');
                    new_sfx.play();
                }
            }

            //----------------------------------
            //Fullscreen 
            //----------------------------------
            var fs = false;
            function fullScreen() {
                fs = !fs;
                if (fs) {
                    if (ctx.canvas.webkitRequestFullscreen) {
                        ctx.canvas.webkitRequestFullscreen();
                    } else if (ctx.canvas.mozRequestFullScreen) {
                        ctx.canvas.mozRequestFullScreen();
                    } else if (ctx.canvas.requestFullscreen) {
                        ctx.canvas.requestFullscreen();
                    } else if (ctx.canvas.msRequestFullscreen) {
                        ctx.canvas.msRequestFullscreen();
                    }
                } else {
                    if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }


            //-----------------
            //Main Menu
            //-----------------
            function mainMenu() {
                mainMenuScreen = true;
                ctx.drawImage(backgroundImage, 0, 0, 320 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                ctx.drawImage(logo, 0, 60 * ctx.canvas.height / 480, 320 * ctx.canvas.width / 320, 136 * ctx.canvas.height / 480);
                ctx.drawImage(playButton, 28 * ctx.canvas.width / 320, 240 * ctx.canvas.height / 480, 264 * ctx.canvas.width / 320, 54 * ctx.canvas.height / 480);
                ctx.drawImage(leaderboardButton, 28 * ctx.canvas.width / 320, 320 * ctx.canvas.height / 480, 264 * ctx.canvas.width / 320, 54 * ctx.canvas.height / 480);
                ctx.drawImage(optionsButton, 28 * ctx.canvas.width / 320, 400 * ctx.canvas.height / 480, 264 * ctx.canvas.width / 320, 54 * ctx.canvas.height / 480);
            }

            //---------------------------
            //New game aka restart
            //---------------------------
            function newGame() {
                currentRules = new RuleSet();
                currentRules.newRule();
                df = new Difficulty();
                updateBuffer = [];
                layerBuffer = [];
                bgimgnum = 0;
                backgroundImg.src = "img/backgrounds/" + backgrounds[bgimgnum] + "_background.png";
                frameID = 0;
                entities = 0;
                mainMenuScreen = false;
                mainMenuOptions = false;
                gameOver = false;
                pause = false;
                window.count = 0;
                window.combo = 0;
                updateBuffer.push(sf.createShape("random"));
                df.newGamePeriod = false;
                df.numShapes++;
                start();
            }

            function leaderboardScreen() {
                window.open("leaderboardoverlap.html");
            }

            //------------------------------
            //Main menu options screen
            //------------------------------
            function optionsScreen() {
                mainMenuOptions = true;
                ctx.rect(0, 0, 320 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                ctx.fillStyle = "rgba(0,0,0,.5)";
                ctx.fill();

                ctx.beginPath();
                ctx.lineWidth = "4";
                ctx.strokeStyle = "black";
                ctx.rect(22 * ctx.canvas.width / 320, 70 * ctx.canvas.height / 480, 276 * ctx.canvas.width / 320, 190 * ctx.canvas.height / 480);
                ctx.stroke();

                var grd = ctx.createLinearGradient(0, 70 * ctx.canvas.height / 480, 0, 260 * ctx.canvas.height / 480);
                grd.addColorStop(0, "grey");
                grd.addColorStop(0.2, "lightgrey");
                grd.addColorStop(0.8, "lightgrey");
                grd.addColorStop(1, "grey");
                ctx.fillStyle = grd;
                ctx.fill();

                ctx.fillStyle = "black";
                ctx.font = 30 * ctx.canvas.height / 480 + "px Calibri";
                ctx.fillText("Options", 25 * ctx.canvas.width / 320, 100 * ctx.canvas.height / 480);
                ctx.font = 20 * ctx.canvas.height / 480 + "px Calibri";
                ctx.fillText("Background Music", 70 * ctx.canvas.width / 320, 135 * ctx.canvas.height / 480);
                ctx.fillText("Sound Effects", 70 * ctx.canvas.width / 320, 175 * ctx.canvas.height / 480);
                ctx.fillText("Fullscreen", 70 * ctx.canvas.width / 320, 215 * ctx.canvas.height / 480);

                if (bgm.muted === false) {
                    ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 110 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                } else {
                    ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 110 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }

                if (sfx === true) {
                    ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 150 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                } else {
                    ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 150 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }

                if (fs === false) {
                    ctx.drawImage(fullscreenButtonImg, 30 * ctx.canvas.width / 320, 190 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                } else {
                    ctx.drawImage(restoreButtonImg, 30 * ctx.canvas.width / 320, 190 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }

                ctx.drawImage(closeButtonImg, 280 * ctx.canvas.width / 320, 60 * ctx.canvas.height / 480, 30 * ctx.canvas.width / 320, 30 * ctx.canvas.height / 480);
            }

            //Game over screen
            function gameOverScreen() {
                gameOver = true;
                errorSFX();
                stop();

                ctx.rect(0, 0, 320 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                ctx.fillStyle = "rgba(0,0,0,.5)";
                ctx.fill();

                ctx.beginPath();
                ctx.lineWidth = "4";
                ctx.strokeStyle = "black";
                ctx.rect(22 * ctx.canvas.width / 320, 70 * ctx.canvas.height / 480, 276 * ctx.canvas.width / 320, 190 * ctx.canvas.height / 480);
                ctx.stroke();

                var grd = ctx.createLinearGradient(0, 70 * ctx.canvas.height / 480, 0, 260 * ctx.canvas.height / 480);
                grd.addColorStop(0, "grey");
                grd.addColorStop(0.2, "lightgrey");
                grd.addColorStop(0.8, "lightgrey");
                grd.addColorStop(1, "grey");
                ctx.fillStyle = grd;
                ctx.fill();

                ctx.fillStyle = "black";
                ctx.font = 30 * ctx.canvas.height / 480 + "px Calibri";
                ctx.fillText("Game Over", 25 * ctx.canvas.width / 320, 100 * ctx.canvas.height / 480);

                ctx.font = 20 * ctx.canvas.height / 480 + "px Calibri";
                ctx.fillText("Score: " + window.count, 25 * ctx.canvas.width / 320, 130 * ctx.canvas.height / 480);

                //Temporary variable, actually check in later iteration instead.
                var newRecord = true;
                if (newRecord === true) {
                    ctx.beginPath();
                    ctx.rect(35 * ctx.canvas.width / 320, 150 * ctx.canvas.height / 480, 250 * ctx.canvas.width / 320, 90 * ctx.canvas.height / 480);
                    ctx.stroke();

                    ctx.fillStyle = "black";
                    ctx.font = 20 * ctx.canvas.height / 480 + "px Calibri";
                    ctx.fillText("New High Score", 40 * ctx.canvas.width / 320, 170 * ctx.canvas.height / 480);
                    nameInputHS();
                    submit();
                } else {
                    ctx.fillText("High Score: 9001", 40 * ctx.canvas.width / 320, 170 * ctx.canvas.height / 480);
                }

                ctx.drawImage(menuButtonImg, 20 * ctx.canvas.width / 320, 250 * ctx.canvas.height / 480, 140 * ctx.canvas.width / 320, 44 * ctx.canvas.height / 480);
                ctx.drawImage(restartButtonImg, 160 * ctx.canvas.width / 320, 250 * ctx.canvas.height / 480, 140 * ctx.canvas.width / 320, 44 * ctx.canvas.height / 480);
            }

            //The function to call to make the text box for high score show up
            var textFieldHS = document.createElement("INPUT");
            function nameInputHS() {
                textFieldHS.setAttribute("type", "text");
                textFieldHS.setAttribute("placeholder", "Enter your name");
                textFieldHS.setAttribute("z-index", "1");
                textFieldHS.setAttribute("id", "nameInput");
                textFieldHS.setAttribute("style", "font-size: " + 13 * ctx.canvas.height / 480 + "px");
                document.getElementById("midscreen").appendChild(textFieldHS);
                document.getElementById("midscreen").style.top = 175 * ctx.canvas.height / 480 + "px";
                document.getElementById("midscreen").style.left = 40 * ctx.canvas.width / 320 + "px";

            }
            //The function to call to make the submit button for high score show up
            var submitHS = document.createElement("div");
            function submit() {
                submitHS.setAttribute("type", "text");
                submitHS.setAttribute("value", "Enter your name");
                submitHS.setAttribute("z-index", "1");
                submitHS.setAttribute("id", "zergling");
                submitHS.setAttribute("style", "background-image:url(img/buttons/submit_button.png); background-size:100% 100%;");
                submitHS.style.width = 89 * ctx.canvas.width / 320 + "px";
                submitHS.style.height = 34 * ctx.canvas.height / 480 + "px";
                document.getElementById("midscreenSubmit").appendChild(submitHS);
                document.getElementById("midscreenSubmit").style.top = 200 * ctx.canvas.height / 480 + "px";
                document.getElementById("midscreenSubmit").style.left = 39 * ctx.canvas.width / 320 + "px";
                clickity();
                //$("div").click(function(){
                //alert("submit div was clicked.");
                //});

            }


            var LEADERBOARD_SIZE = 100;


            // Create our Firebase reference
            var scoreListRef = new Firebase('https://zu1g1l7h60o.firebaseio-demo.com//scoreList');

            // Keep a mapping of firebase locations to HTML elements, so we can move / remove elements as necessary.
            var htmlForPath = {};

            // Helper function that takes a new score snapshot and adds an appropriate row to our leaderboard table.
            function handleScoreAdded(scoreSnapshot, prevScoreName) {


                var newScoreRow = $("<tr/>");
                newScoreRow.append($("<td/>").append($("<em/>").text("")));

                newScoreRow.append($("<td/>").append($("<em/>").text(scoreSnapshot.val().name)));
                newScoreRow.append($("<td/>").text(scoreSnapshot.val().score));

                // Store a reference to the table row so we can get it again later.
                htmlForPath[scoreSnapshot.key()] = newScoreRow;

                // Insert the new score in the appropriate place in the table.
                if (prevScoreName === null) {
                    $("#leaderboardTable").append(newScoreRow);
                } else {
                    var lowerScoreRow = htmlForPath[prevScoreName];
                    lowerScoreRow.before(newScoreRow);
                }
            }

            // Helper function to handle a score object being removed; just removes the corresponding table row.
            function handleScoreRemoved(scoreSnapshot) {
                var removedScoreRow = htmlForPath[scoreSnapshot.key()];
                removedScoreRow.remove();
                delete htmlForPath[scoreSnapshot.key()];
            }

            // Create a view to only receive callbacks for the last LEADERBOARD_SIZE scores
            var scoreListView = scoreListRef.limitToLast(LEADERBOARD_SIZE);

            // Add a callback to handle when a new score is added.
            scoreListView.on('child_added', function (newScoreSnapshot, prevScoreName) {
                handleScoreAdded(newScoreSnapshot, prevScoreName);
            });

            // Add a callback to handle when a score is removed
            scoreListView.on('child_removed', function (oldScoreSnapshot) {
                handleScoreRemoved(oldScoreSnapshot);
            });

            // Add a callback to handle when a score changes or moves positions.
            var changedCallback = function (scoreSnapshot, prevScoreName) {
                handleScoreRemoved(scoreSnapshot);
                handleScoreAdded(scoreSnapshot, prevScoreName);
            };
            scoreListView.on('child_moved', changedCallback);
            scoreListView.on('child_changed', changedCallback);


            // When the user presses enter on SubmitButton, add the score, and update the highest score.

            function clickity() {

                $(document).ready(function () {
                    $("#zergling").click(function () {
                        var newScore = window.count; //Number($("#scoreInput").val());
                        var name = $("#nameInput").val();
                        //$("#scoreInput").val("");

                        if (name.length === 0)
                            return;

                        var timestampName = name + Date.now();
                        var userScoreRef = scoreListRef.child(timestampName);

                        // Use setWithPriority to put the name / score in Firebase, and set the priority to be the score.
                        userScoreRef.setWithPriority({ name: name, score: newScore }, newScore);
                        document.getElementById("midscreen").removeChild(textFieldHS);
                        document.getElementById("midscreenSubmit").removeChild(submitHS);
                    });
                });
            }
        </script>
    </body>
</html>