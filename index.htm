<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
        <link type="text/css" rel="stylesheet" href="css/style.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
    </head>
    <body>
        <audio id="background_audio" autoplay="autoplay" loop="loop">
            <source src="audio/strike_the_earth.mp3" type="audio/mpeg" />
        </audio>
        <canvas id="canvas" width="320" height="480">
            Your browser does not support the HTML5 canvas tag.
        </canvas>
        <script>
            var ctx = document.getElementById("canvas").getContext("2d"),
            limit = 300,
            lastFrameTimeMs = 0,
            maxFPS = 60,
            delta = 0,
            timestep = 1000 / 60,
            fps = 60,
            framesThisSecond = 0,
            lastFpsUpdate = 0,
            running = false,
            started = false,
            frameID = 0;
            entities = 0;
            mainMenuScreen = false;
            mainMenuOptions = false;
            gameOver = false;
            pause = false;
            var currentRules = null;
            window.count = 0;
            window.combo = 0;
            
            //---------------------------------------
            //Constructor for a Circle
            //---------------------------------------
            function Circle(x, y, z, xVelocity, yVelocity, colour) {
                var randomColour = ["red", "blue", "green", "yellow"];
                var bodyImg = new Image();
                this.shapeType = "Circle";
                this.xCurrent = x || 0;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = z || 0;
                this.xVelocity = xVelocity || 0;
                this.yVelocity = yVelocity || 0.1;
                this.clicked = false;
                this.checked = false;
                entities++;                
                if (colour == "random") {
                    this.colour = randomColour[Math.floor(Math.random()*4)];
                } else {
                    this.colour = colour || randomColour[Math.floor(Math.random()*4)];
                }
                
                if (this.colour == "red") {
                    bodyImg.src = "img/shapes/circle/red_circle.png";
                } else if (this.colour == "blue") {
                    bodyImg.src = "img/shapes/circle/blue_circle.png";
                } else if (this.colour == "green") {
                    bodyImg.src = "img/shapes/circle/green_circle.png";
                } else if (this.colour == "yellow") {
                    bodyImg.src = "img/shapes/circle/yellow_circle.png";
                }
                
                this.draw = function(interp) {
                    ctx.drawImage(bodyImg, this.xPrevious + (this.xCurrent - this.xPrevious) * interp, this.yPrevious + (this.yCurrent - this.yPrevious) * interp, 64 * ctx.canvas.width / 320, 64 * ctx.canvas.height / 480);
                }
                this.update = function() {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }
                this.offScreen = function() {
                return this.xCurrent >= canvas.width || this.yCurrent >= canvas.height;
                }
                
                this.contains = function(mx, my) {
                // All we have to do is make sure the Mouse X,Y fall in the area between
                // the shape's X and (X + Width) and its Y and (Y + Height)
                return  (this.xCurrent <= mx) && (this.xCurrent + 64 * ctx.canvas.width / 320 >= mx) &&
                        (this.yCurrent <= my) && (this.yCurrent + 64 * ctx.canvas.height / 480 >= my);
                }
            }
            
            //---------------------------------------
            //Constructor for a Square
            //---------------------------------------
            function Square(x, y, z, xVelocity, yVelocity, colour) {
                var randomColour = ["red", "blue", "green", "yellow"];
                var bodyImg = new Image();
                this.shapeType = "Square";
                this.xCurrent = x || 0;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = z || 0;
                this.xVelocity = xVelocity || 0;
                this.yVelocity = yVelocity || 0.1;
                this.clicked = false;
                this.checked = false;
                entities++;
                if (colour == "random") {
                    this.colour = randomColour[Math.floor(Math.random()*4)];
                } else {
                    this.colour = colour || randomColour[Math.floor(Math.random()*4)];
                }
                
                if (this.colour == "red") {
                    bodyImg.src = "img/shapes/square/red_square.png";
                } else if (this.colour == "blue") {
                    bodyImg.src = "img/shapes/square/blue_square.png";
                } else if (this.colour == "green") {
                    bodyImg.src = "img/shapes/square/green_square.png";
                } else if (this.colour == "yellow") {
                    bodyImg.src = "img/shapes/square/yellow_square.png";
                }
                
                this.draw = function(interp) {
                    ctx.drawImage(bodyImg, this.xPrevious + (this.xCurrent - this.xPrevious) * interp, this.yPrevious + (this.yCurrent - this.yPrevious) * interp, 64 * ctx.canvas.width / 320, 64 * ctx.canvas.height / 480);
                }
                this.update = function() {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }
                this.offScreen = function() {
                return this.xCurrent >= canvas.width || this.yCurrent >= canvas.height;
                }
                this.contains = function(mx, my) {
                // All we have to do is make sure the Mouse X,Y fall in the area between
                // the shape's X and (X + Width) and its Y and (Y + Height)
                return  (this.xCurrent <= mx) && (this.xCurrent + 64 * ctx.canvas.width / 320 >= mx) &&
                        (this.yCurrent <= my) && (this.yCurrent + 64 * ctx.canvas.height / 480 >= my);
                }
            }
            
            //---------------------------------------
            //Constructor for a Triangle
            //---------------------------------------
            function Triangle(x, y, z, xVelocity, yVelocity, colour) {
                var randomColour = ["red", "blue", "green", "yellow"];
                var bodyImg = new Image();
                this.shapeType = "Triangle";
                this.xCurrent = x || 0;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = z || 0;
                this.xVelocity = xVelocity || 0;
                this.yVelocity = yVelocity || 0.1;
                this.clicked = false;
                this.checked = false;
                entities++; 
                
                if (colour == "random") {
                    this.colour = randomColour[Math.floor(Math.random()*4)];
                } else {
                    this.colour = colour || randomColour[Math.floor(Math.random()*4)];
                }
                
                if (this.colour == "red") {
                    bodyImg.src = "img/shapes/triangle/red_triangle.png";
                } else if (this.colour == "blue") {
                    bodyImg.src = "img/shapes/triangle/blue_triangle.png";
                } else if (this.colour == "green") {
                    bodyImg.src = "img/shapes/triangle/green_triangle.png";
                } else if (this.colour == "yellow") {
                    bodyImg.src = "img/shapes/triangle/yellow_triangle.png";
                }
                
                this.draw = function(interp) {
                    ctx.drawImage(bodyImg, this.xPrevious + (this.xCurrent - this.xPrevious) * interp, this.yPrevious + (this.yCurrent - this.yPrevious) * interp, 64 * ctx.canvas.width / 320, 64 * ctx.canvas.height / 480);
                }
                this.update = function() {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }
                this.offScreen = function() {
                    return this.xCurrent >= canvas.width || this.yCurrent >= canvas.height;
                }
                this.contains = function(mx, my) {
                // All we have to do is make sure the Mouse X,Y fall in the area between
                // the shape's X and (X + Width) and its Y and (Y + Height)
                return  (this.xCurrent <= mx) && (this.xCurrent + 64 * ctx.canvas.width / 320 >= mx) &&
                        (this.yCurrent <= my) && (this.yCurrent + 64 * ctx.canvas.height / 480 >= my);
                }
                
            }
            
            //---------------------------------------
            //Constructor for a Star
            //---------------------------------------
            function Star(x, y, z, xVelocity, yVelocity) {
                var bodyImg = new Image();
                this.shapeType = "Star";
                this.colour = "yellow";
                bodyImg.src = "img/shapes/star/star.png";  
                this.xCurrent = x || 0;
                this.xPrevious = this.xCurrent;
                this.yCurrent = y || -64 * ctx.canvas.height / 480;
                this.yPrevious = this.yCurrent;
                this.layer = z || 0;
                this.xVelocity = xVelocity || 0;
                this.yVelocity = yVelocity || 0.1;
                this.clicked = false;
                this.checked = false;
                entities++;
                this.draw = function(interp) {
                    ctx.drawImage(bodyImg, this.xPrevious + (this.xCurrent - this.xPrevious) * interp, this.yPrevious + (this.yCurrent - this.yPrevious) * interp, 64 * ctx.canvas.width / 320, 64 * ctx.canvas.height / 480);
                }
                this.update = function() {
                    this.xPrevious = this.xCurrent;
                    this.yPrevious = this.yCurrent;
                    this.xCurrent += this.xVelocity * delta;
                    this.yCurrent += this.yVelocity * delta;
                }
                this.offScreen = function() {
                return this.xCurrent >= canvas.width || this.yCurrent >= canvas.height;
                }
                this.contains = function(mx, my) {
                // All we have to do is make sure the Mouse X,Y fall in the area between
                // the shape's X and (X + Width) and its Y and (Y + Height)
                return  (this.xCurrent <= mx) && (this.xCurrent + 64 * ctx.canvas.width / 320 >= mx) &&
                        (this.yCurrent <= my) && (this.yCurrent + 64 * ctx.canvas.height / 480 >= my);
            }
            }
            
            //The way that the factory works is you call createShape() with a parameter
            //the parameter is a string of which shape to be created or random
            //eg. ShapeFactory.createShape("blueCircle");
            //or 
            //ShapeFactory.createShape("random");
            function ShapeFactory() { }
            
            //---------------------
            //spawnCheck method
            //---------------------
            ShapeFactory.prototype.spawnCheck = function spawnCheck(shape) {
                var spawnBox = 0;
                if (shape.yCurrent > spawnBox) {
                    shape.checked = true;
                    return true;
                } else {
                    return false;
                }
            };
            //---------------------
            //createShape method
            //---------------------
            ShapeFactory.prototype.createShape = function createShape(type) {
                var randomShape = ["Circle", "Square", "Triangle"];
                var lane = [0, 64 * ctx.canvas.width / 320, 128 * ctx.canvas.width / 320, 192 * ctx.canvas.width / 320, 256 * ctx.canvas.width / 320];
                if (type == "circle") {
                    return new Circle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "random");
                } else if (type == "square") {
                    return new Square(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "random");
                } else if (type == "triangle") {
                    return new Triangle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "random");
                } else if (type == "redCircle") {
                    return new Circle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "red");
                } else if (type == "blueCircle") {
                    return new Circle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "blue");
                } else if (type == "greenCircle") {
                    return new Circle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "green");
                } else if (type == "yellowCircle") {
                    return new Circle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "yellow");
                } else if (type == "redSquare") {
                    return new Square(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "red");
                } else if (type == "blueSquare") {
                    return new Square(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "blue");
                } else if (type == "greenSquare") {
                    return new Square(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "green");
                } else if (type == "yellowSquare") {
                    return new Square(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "yellow");
                } else if (type == "redTriangle") {
                    return new Triangle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "red");
                } else if (type == "blueTriangle") {
                    return new Triangle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "blue");
                } else if (type == "greenTriangle") {
                    return new Triangle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "green");
                } else if (type == "yellowTriangle") {
                    return new Triangle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "yellow");
                } else if (type == "star") {
                    return new Star(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null);
                } else if (type == "random") {
                    var rs = randomShape[Math.floor(Math.random()*3)];
                    
                    if (rs == "Circle") {
                        return new Circle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "random");
                    } else if(rs == "Square") {
                        return new Square(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "random");
                    } else if (rs == "Triangle") {
                        return new Triangle(lane[Math.floor(Math.random()*5)], -64 * ctx.canvas.height / 480, null, null, null, "random");
                    }
                }
                return;
            };
            //--------------------------------------------
            //Rule Logic
            //--------------------------------------------
            function Rule(type) {
                this.type = type;

                Rule.prototype.toString = function ruleToString() {
                    var ret = this.type + "\n";
                    return ret;
                };
            }

            function RuleSet() {
                this.rules = new Array();
                this.availableRules = ["red", "nored", "blue", "noblue", "green", "nogreen", "yellow", "noyellow", "Circle", "noCircle", "Square", "noSquare", "Triangle", "noTriangle"];
                this.newRule = function () {
                    var rand = Math.floor(Math.random() * this.availableRules.length);
                    this.rules.push(new Rule(this.availableRules[rand]));

                    if (rand % 2 === 0) {
                        this.availableRules.splice(rand, 2);
                    } else {
                        this.availableRules.splice(rand - 1, 2);
                    }
                };
            }
            
            canvas.addEventListener('mousedown', function(e) {
                var mouse = getMouse(e);
                var mx = mouse.x;
                var my = mouse.y;
                var l = updateBuffer.length;
                
                if(mainMenuOptions === true) {
                    if(mx >= 280 * ctx.canvas.width / 320 && mx <= 310 * ctx.canvas.width / 320 && my >= 60 * ctx.canvas.height / 480 && my <= 90 * ctx.canvas.height / 480) {
                        mainMenuOptions = false;
                        mainMenu();
                    } else if(mx >= 30 * ctx.canvas.width / 320 && mx <= 65 * ctx.canvas.width / 320 && my >= 110 * ctx.canvas.height / 480 && my <= 145 * ctx.canvas.height / 480) {
                        toggleBGM();
                        if(bgm.muted === false) {
                            ctx.drawImage(speakerImg,30 * ctx.canvas.width / 320,110 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        } else {
                            ctx.drawImage(muteImg,30 * ctx.canvas.width / 320,110 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        }
                    } else if(mx >= 30 * ctx.canvas.width / 320 && mx <= 65 * ctx.canvas.width / 320 && my >= 150 * ctx.canvas.height / 480 && my <= 185 * ctx.canvas.height / 480) {
                        toggleSFX();
                        if(sfx === true) {
                            ctx.drawImage(speakerImg,30 * ctx.canvas.width / 320,150 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        } else {
                            ctx.drawImage(muteImg,30 * ctx.canvas.width / 320,150 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        }
                    }
                } else if(mainMenuScreen === true) {
                    if(mx >= 28 * ctx.canvas.width / 320 && mx <= 292 * ctx.canvas.width / 320 && my >= 240 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        newGame();
                    } else if(mx >= 28 && mx <= 292 && my >= 320 * ctx.canvas.height / 480 && my <= 374 * ctx.canvas.height / 480) { 
                        //Leaderboard
                    } else if(mx >= 28 * ctx.canvas.width / 320 && mx <= 292 * ctx.canvas.width / 320 && my >= 400 * ctx.canvas.height / 480 && my <= 454 * ctx.canvas.height / 480) {
                        optionsScreen();
                    }
                } else if(gameOver === true) {
                    if(mx >= 20 * ctx.canvas.width / 320 && mx <= 159 * ctx.canvas.width / 320 && my >= 250 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        mainMenu();
                    } else if(mx >= 160 * ctx.canvas.width / 320 && mx <= 300 * ctx.canvas.width / 320 && my >= 250 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        newGame();
                    }
                } else if(pause === true) {
                    if(mx >= 280 * ctx.canvas.width / 320 && mx <= 310 * ctx.canvas.width / 320 && my >= 60 * ctx.canvas.height / 480 && my <= 90 * ctx.canvas.height / 480) {
                        pause = false;
                        start();
                    } else if(mx >= 30 * ctx.canvas.width / 320 && mx <= 65 * ctx.canvas.width / 320 && my >= 170 * ctx.canvas.height / 480 && my <= 205 * ctx.canvas.height / 480) { 
                        toggleBGM();
                        if(bgm.muted === false) {
                            ctx.drawImage(speakerImg,30 * ctx.canvas.width / 320,170 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        } else {
                            ctx.drawImage(muteImg,30 * ctx.canvas.width / 320,170 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        }
                    } else if(mx >= 30 * ctx.canvas.width / 320 && mx <= 65 * ctx.canvas.width / 320 && my >= 210 * ctx.canvas.height / 480 && my <= 245 * ctx.canvas.height / 480) {
                        toggleSFX();
                        if(sfx === true) {
                            ctx.drawImage(speakerImg,30 * ctx.canvas.width / 320,210 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        } else {
                            ctx.drawImage(muteImg,30 * ctx.canvas.width / 320,210 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                        }
                    } else if(mx >= 20 * ctx.canvas.width / 320 && mx <= 159 * ctx.canvas.width / 320 && my >= 250 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        mainMenu();
                    } else if(mx >= 160 * ctx.canvas.width / 320 && mx <= 300 * ctx.canvas.width / 320 && my >= 250 * ctx.canvas.height / 480 && my <= 294 * ctx.canvas.height / 480) {
                        newGame();
                    }
                } else if(pause === false && mx >= 290 * ctx.canvas.width / 320 && my <= 30 * ctx.canvas.height / 480) {
                    pauseScreen();
                } else if(pause === false) {
                    for (var i = 0; i < l; i++) {
                        if (updateBuffer[i].contains(mx, my)) {
                            updateBuffer[i].clicked = true;
                            return;
                        }
                    }
                }
            }, true);
            
            canvas.addEventListener('mouseup', function(e) {}, true);
             
            var sf = new ShapeFactory();
            var rs = new RuleSet();
            var updateBuffer = [];
            var layerBuffer = [];
            
            
            /*TODO WTF?
            Shape.prototype.hit = function(mouse) {
                mx = getMouse(mouse).x;
                my = getMouse(mouse).y;
                ctx.fillText("x: " + x, 180, 480);
                ctx.fillText("y: " + entities, 180, 480);
            }*/
            
            getMouse = function(mouseEvent) {
                var element = this.canvas, offsetX = 0, offsetY = 0, mx, my;
                if (element.offsetParent !== undefined) {
                    do {
                        offsetX += element.offsetLeft;
                        offsetY += element.offsetTop;
                    } while ((element = element.offsetParent));
                }
                //offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;
                //offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;
                mx = mouseEvent.pageX;// - offsetX;
                my = mouseEvent.pageY;// - offsetY;
                return {x: mx, y: my};
            }
            
            //------------------------------------------
            //UPDATE BUFFER
            //------------------------------------------
            function update(delta) {
                var l = updateBuffer.length,
                s = 0;
                for (var i = 0; i < l; i++) {
                
                if (updateBuffer[i - s] instanceof Circle ||
                            updateBuffer[i - s] instanceof Square ||
                            updateBuffer[i - s] instanceof Triangle ||
                            updateBuffer[i - s] instanceof Star) {
                                if (updateBuffer[i - s].checked === false && 
                                sf.spawnCheck(updateBuffer[i - s]) === true) {
                                    updateBuffer.push(sf.createShape("random"));
                                }
                        }
                    if(updateBuffer[i - s].offScreen()) {
                        for(var j = 0; j < currentRules.rules.length; j++) {
                            if(currentRules.rules[j].type === updateBuffer[i - s].shapeType || currentRules.rules[j].type === updateBuffer[i - s].colour) {
                                gameOver = true;
                            } else if(currentRules.rules[j].type === "no" + updateBuffer[i - s].shapeType || currentRules.rules[j].type === "no" + updateBuffer[i - s].colour) {
                                //Do nothing, should pass
                            } else if(currentRules.rules[j].type.slice(0,2) === "no") {
                                gameOver = true;
                            }
                        }
                        updateBuffer.splice(i - s, 1);
                        s++;
                        entities--;
                    } else if (updateBuffer[i - s].clicked === true) {
                        for(var j = 0; j < currentRules.rules.length; j++) {
                            if(currentRules.rules[j].type === updateBuffer[i - s].shapeType || currentRules.rules[j].type === updateBuffer[i - s].colour) {
                                rulePass();
                            } else if(currentRules.rules[j].type === "no" + updateBuffer[i - s].shapeType || currentRules.rules[j].type === "no" + updateBuffer[i - s].colour) {
                                ruleFail();
                            } else if(currentRules.rules[j].type.slice(0,2) === "no") {
                                rulePass();
                            } else {
                                ruleFail();
                            }
                        }
                        updateBuffer.splice(i - s, 1);
                        s++;
                        entities--;
                    } else {
                        updateBuffer[i - s].update(delta);
                        layerBuffer.push(updateBuffer[i - s]);
                    }
                }
                layerBuffer.sort(function(a, b) {
                    return b.layer - a.layer;
                });
            }
            
            function rulePass() {
                if(window.combo === 0) {
                    window.count += ++window.combo;
                } else {
                    window.count += Math.ceil(Math.log2(++window.combo));
                }
                validSFX();
            }
            
            function ruleFail() {
                window.combo = 0;
                errorSFX();
            }

            //----------------------------------------------------------
            //Draw
            //----------------------------------------------------------
            function draw(interp) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // ** Add stuff you want drawn in the background all the time here **
                    
                var backgroundImg = new Image();
                backgroundImg.src = "img/nebula_background.png";
                ctx.drawImage(backgroundImg, 0, 0, 320 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                
                ctx.strokeStyle="grey";
                ctx.lineWidth="2";
                ctx.beginPath();
                ctx.moveTo(64 * ctx.canvas.width / 320,0);
                ctx.lineTo(64 * ctx.canvas.width / 320,480 * ctx.canvas.height / 480);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(128 * ctx.canvas.width / 320,0);
                ctx.lineTo(128 * ctx.canvas.width / 320,480 * ctx.canvas.height / 480);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(192 * ctx.canvas.width / 320,0);
                ctx.lineTo(192 * ctx.canvas.width / 320,480 * ctx.canvas.height / 480);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(256 * ctx.canvas.width / 320,0);
                ctx.lineTo(256 * ctx.canvas.width / 320,480 * ctx.canvas.height / 480);
                ctx.stroke();
                
                var l = layerBuffer.length;
                for (var i = 0; i < l; i++) {
                    layerBuffer[i].draw(interp);
                }
                layerBuffer = [];
                ctx.fillStyle ="white";
                ctx.fillText("FPS: " + Math.round(fps),180 * ctx.canvas.width / 320,410 * ctx.canvas.height / 480);
                //ctx.fillText("Entities: " + entities,180,440);
                
                // ** Add stuff you want drawn on top all the time here **
                ctx.rect(0,0,320 * ctx.canvas.width / 320,35 * ctx.canvas.height / 480);
                var grd=ctx.createLinearGradient(0,0,0,35 * ctx.canvas.height / 480);
                grd.addColorStop(0,"grey");
                grd.addColorStop(0.2,"lightgrey");
                grd.addColorStop(0.8,"lightgrey");
                grd.addColorStop(1,"grey");
                ctx.fillStyle=grd;
                ctx.fill();
                
                ctx.strokeStyle="black";
                ctx.beginPath();
                ctx.moveTo(0,35 * ctx.canvas.height / 480);
                ctx.lineTo(320 * ctx.canvas.width / 320,35 * ctx.canvas.height / 480);
                ctx.stroke();
                
                ctx.fillStyle = "black";
                ctx.font = "30px Calibri";
                ctx.fillText("Score: " + window.count,0,30 * ctx.canvas.height / 480);
                
                ctx.textAlign="end";
                if(window.combo <= 1) {
                    ctx.fillText(window.combo + "x",280 * ctx.canvas.width / 320,30 * ctx.canvas.height / 480);
                } else {
                    ctx.fillText(Math.ceil(Math.log2(window.combo)) + "x",280 * ctx.canvas.width / 320,30 * ctx.canvas.height / 480);
                }
                ctx.textAlign="start";
                
                var pauseButtonImg = new Image();
                pauseButtonImg.src = "img/pause.png";
                ctx.drawImage(pauseButtonImg, 285 * ctx.canvas.width / 320, 0, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                
                ctx.rect(0,445 * ctx.canvas.height / 480,320 * ctx.canvas.width / 320,480 * ctx.canvas.height / 480);
                var grd=ctx.createLinearGradient(0,445 * ctx.canvas.height / 480,0,480 * ctx.canvas.height / 480);
                grd.addColorStop(0,"grey");
                grd.addColorStop(0.2,"lightgrey");
                grd.addColorStop(0.8,"lightgrey");
                grd.addColorStop(1,"grey");
                ctx.fillStyle=grd;
                ctx.fill();
                
                ctx.strokeStyle="black";
                ctx.beginPath();
                ctx.moveTo(0,445 * ctx.canvas.height / 480);
                ctx.lineTo(320 * ctx.canvas.width / 320,445 * ctx.canvas.height / 480);
                ctx.stroke();
                
                ctx.fillStyle = "black";
                ctx.font = "30px Calibri";
                ctx.fillText("Rules: " + currentRules.rules[0],0,475 * ctx.canvas.height / 480);
            }

            function panic() {
                delta = 0;
                ctx.fillText("Panic",100 * ctx.canvas.width / 320,200 * ctx.canvas.height / 480);
            }
            
            //function begin() {
            //}
            
            function end(fps) {
                if (fps < 25) {
                    entities = 0;
                    updateBuffer = [];
                }
            }

            function stop() {
                running = false;
                started = false;
                cancelAnimationFrame(frameID);
            }

            function start() {
                if (!started) {
                    started = true;
                    frameID = requestAnimationFrame(function(timestamp) {
                        draw(1);
                        running = true;
                        lastFrameTimeMs = timestamp;
                        lastFpsUpdate = timestamp;
                        framesThisSecond = 0;
                        frameID = requestAnimationFrame(mainLoop);
                    });
                }
            }

            function mainLoop(timestamp) {
                // Throttle the frame rate.    
                if (timestamp < lastFrameTimeMs + (1000 / maxFPS)) {
                    frameID = requestAnimationFrame(mainLoop);
                    return;
                }
                delta += timestamp - lastFrameTimeMs;
                lastFrameTimeMs = timestamp;

                //begin(timestamp, delta);

                if (timestamp > lastFpsUpdate + 1000) {
                    fps = 0.25 * framesThisSecond + 0.75 * fps;
                    
                    lastFpsUpdate = timestamp;
                    framesThisSecond = 0;
                }
                framesThisSecond++;

                var numUpdateSteps = 0;
                while (delta >= timestep) {
                    update(timestep);
                    delta -= timestep;
                    if (++numUpdateSteps >= 240) {
                        panic();
                        break;
                    }
                }

                draw(delta / timestep);
                
                end(fps);
                
                frameID = requestAnimationFrame(mainLoop);
                
                if(gameOver === true) {
                    gameOverScreen();
                }
            }
            
            window.onload = function() {
                mainMenu();
            };
            
            var backgroundImage = new Image();
            backgroundImage.src = "img/star_background.png";
            var logo = new Image();
            logo.src = "img/logo.png";
            var playButton = new Image();
            playButton.src = "img/play_button.png";
            var leaderboardButton = new Image();
            leaderboardButton.src = "img/leaderboard_button.png";
            var optionsButton = new Image();
            optionsButton.src = "img/options_button.png";
            var menuButtonImg = new Image();
            menuButtonImg.src = "img/mainmenu.png";
            var restartButtonImg = new Image();
            restartButtonImg.src = "img/restart.png";
            var closeButtonImg = new Image();
            closeButtonImg.src = "img/close.png";
            var speakerImg = new Image();
            speakerImg.src = "img/speaker.png";
            var muteImg = new Image();
            muteImg.src = "img/mute.png";
            
            //Pause menu drawing
            function pauseScreen() {
                pause = true;
                stop();
                
                ctx.rect(0,35 * ctx.canvas.height / 480,320 * ctx.canvas.width / 320,410 * ctx.canvas.height / 480);
                ctx.fillStyle="rgba(0,0,0,.5)";
                ctx.fill();
                
                ctx.beginPath();
                ctx.lineWidth="4";
                ctx.strokeStyle="black";
                ctx.rect(22 * ctx.canvas.width / 320,70 * ctx.canvas.height / 480,276 * ctx.canvas.width / 320,190 * ctx.canvas.height / 480);
                ctx.stroke();
                
                var grd=ctx.createLinearGradient(0,70 * ctx.canvas.height / 480,0,260 * ctx.canvas.height / 480);
                grd.addColorStop(0,"grey");
                grd.addColorStop(0.2,"lightgrey");
                grd.addColorStop(0.8,"lightgrey");
                grd.addColorStop(1,"grey");
                ctx.fillStyle=grd;
                ctx.fill();
                
                ctx.fillStyle = "black";
                ctx.font = "20px Calibri";
                ctx.fillText("Current Rule: ",25 * ctx.canvas.width / 320,90 * ctx.canvas.height / 480);
                
                ctx.beginPath();
                ctx.lineWidth="2";
                ctx.moveTo(30 * ctx.canvas.width / 320,165 * ctx.canvas.height / 480);
                ctx.lineTo(290 * ctx.canvas.width / 320,165 * ctx.canvas.height / 480);
                ctx.stroke();
                
                ctx.fillText("Background Music",70 * ctx.canvas.width / 320,195 * ctx.canvas.height / 480);
                ctx.fillText("Sound Effects",70 * ctx.canvas.width / 320,235 * ctx.canvas.height / 480);
                
                if(bgm.muted === false) {
                    ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 170 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                } else {
                    ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 170 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }
                
                if(sfx === true) {
                    ctx.drawImage(speakerImg, 30 * ctx.canvas.width / 320, 210 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                } else {
                    ctx.drawImage(muteImg, 30 * ctx.canvas.width / 320, 210 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }
                
                ctx.drawImage(menuButtonImg,20 * ctx.canvas.width / 320,250 * ctx.canvas.height / 480, 140 * ctx.canvas.width / 320, 44 * ctx.canvas.height / 480);
                ctx.drawImage(restartButtonImg,160 * ctx.canvas.width / 320,250 * ctx.canvas.height / 480, 140 * ctx.canvas.width / 320, 44 * ctx.canvas.height / 480);
                ctx.drawImage(closeButtonImg,280 * ctx.canvas.width / 320,60 * ctx.canvas.height / 480, 30 * ctx.canvas.width / 320, 30 * ctx.canvas.height / 480);
            }
            
            //BGM toggle variable and function
            var bgm = document.getElementById('background_audio');
            function toggleBGM() { 
                bgm.muted = !bgm.muted;
            }
            
            //SFX toggle function, don't play sounds if false.
            var sfx = true;
            function toggleSFX() { 
                sfx = !sfx;
            }
            
            //Valid SFX
            function validSFX() {
                if(sfx === true) {
                    var new_sfx = new Audio('audio/valid.mp3');
                    new_sfx.play();
                }
            }
            
            //Error SFX
            function errorSFX() {
                if(sfx === true) {
                    var new_sfx = new Audio('audio/error.mp3');
                    new_sfx.play();
                }
            }
            
            //Main Menu
            function mainMenu() {
                mainMenuScreen = true;
                ctx.drawImage(backgroundImage,0,0, 320 * ctx.canvas.width / 320, 480 * ctx.canvas.height / 480);
                ctx.drawImage(logo,0,60 * ctx.canvas.height / 480, 320 * ctx.canvas.width / 320, 136 * ctx.canvas.height / 480);
                ctx.drawImage(playButton,28 * ctx.canvas.width / 320,240 * ctx.canvas.height / 480, 264 * ctx.canvas.width / 320, 54 * ctx.canvas.height / 480);
                ctx.drawImage(leaderboardButton,28 * ctx.canvas.width / 320,320 * ctx.canvas.height / 480, 264 * ctx.canvas.width / 320, 54 * ctx.canvas.height / 480);
                ctx.drawImage(optionsButton,28 * ctx.canvas.width / 320,400 * ctx.canvas.height / 480, 264 * ctx.canvas.width / 320, 54 * ctx.canvas.height / 480);
            }
            
            //New game aka restart
            function newGame() {
                currentRules = new RuleSet();
                currentRules.newRule();
                updateBuffer = [];
                layerBuffer = [];
                updateBuffer.push(sf.createShape("random"));
                frameID = 0;
                entities = 0;
                mainMenuScreen = false;
                mainMenuOptions = false;
                gameOver = false;
                pause = false;
                window.count = 0;
                window.combo = 0;
                start();
            }
            
            //Main menu options screen
            function optionsScreen() {
                mainMenuOptions = true;
                ctx.rect(0,0,320 * ctx.canvas.width / 320,480 * ctx.canvas.height / 480);
                ctx.fillStyle="rgba(0,0,0,.5)";
                ctx.fill();
                
                ctx.beginPath();
                ctx.lineWidth="4";
                ctx.strokeStyle="black";
                ctx.rect(22 * ctx.canvas.width / 320,70 * ctx.canvas.height / 480,276 * ctx.canvas.width / 320,190 * ctx.canvas.height / 480);
                ctx.stroke();
                
                var grd=ctx.createLinearGradient(0,70 * ctx.canvas.height / 480,0,260 * ctx.canvas.height / 480);
                grd.addColorStop(0,"grey");
                grd.addColorStop(0.2,"lightgrey");
                grd.addColorStop(0.8,"lightgrey");
                grd.addColorStop(1,"grey");
                ctx.fillStyle=grd;
                ctx.fill();
                
                ctx.fillStyle = "black";
                ctx.font = "30px Calibri";
                ctx.fillText("Options",25 * ctx.canvas.width / 320,100 * ctx.canvas.height / 480);
                ctx.font = "20px Calibri";
                ctx.fillText("Background Music",70 * ctx.canvas.width / 320,135 * ctx.canvas.height / 480);
                ctx.fillText("Sound Effects",70 * ctx.canvas.width / 320,175 * ctx.canvas.height / 480);
                
                if(bgm.muted === false) {
                    ctx.drawImage(speakerImg,30 * ctx.canvas.width / 320,110 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                } else {
                    ctx.drawImage(muteImg,30 * ctx.canvas.width / 320,110 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }
                
                if(sfx === true) {
                    ctx.drawImage(speakerImg,30 * ctx.canvas.width / 320,150 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                } else {
                    ctx.drawImage(muteImg,30 * ctx.canvas.width / 320,150 * ctx.canvas.height / 480, 35 * ctx.canvas.width / 320, 35 * ctx.canvas.height / 480);
                }
                
                ctx.drawImage(closeButtonImg,280 * ctx.canvas.width / 320,60 * ctx.canvas.height / 480, 30 * ctx.canvas.width / 320, 30 * ctx.canvas.height / 480);
            }
            
            //Game over screen
            function gameOverScreen() {
                gameOver = true;
                errorSFX();
                stop();
                
                ctx.rect(0,0,320 * ctx.canvas.width / 320,480 * ctx.canvas.height / 480);
                ctx.fillStyle="rgba(0,0,0,.5)";
                ctx.fill();
                
                ctx.beginPath();
                ctx.lineWidth="4";
                ctx.strokeStyle="black";
                ctx.rect(22 * ctx.canvas.width / 320,70 * ctx.canvas.height / 480,276 * ctx.canvas.width / 320,190 * ctx.canvas.height / 480);
                ctx.stroke();
                
                var grd=ctx.createLinearGradient(0,70 * ctx.canvas.height / 480,0,260 * ctx.canvas.height / 480);
                grd.addColorStop(0,"grey");
                grd.addColorStop(0.2,"lightgrey");
                grd.addColorStop(0.8,"lightgrey");
                grd.addColorStop(1,"grey");
                ctx.fillStyle=grd;
                ctx.fill();
                
                ctx.fillStyle = "black";
                ctx.font = "30px Calibri";
                ctx.fillText("Game Over",25 * ctx.canvas.width / 320,100 * ctx.canvas.height / 480);
                
                ctx.font = "20px Calibri";
                ctx.fillText("Score: " + window.count,25 * ctx.canvas.width / 320,130 * ctx.canvas.height / 480);
                
                //Temporary variable, actually check in later iteration instead.
                var newRecord = false;
                if(newRecord === true) {
                    ctx.beginPath();
                    ctx.rect(35 * ctx.canvas.width / 320,150 * ctx.canvas.height / 480,250 * ctx.canvas.width / 320,90 * ctx.canvas.height / 480);
                    ctx.stroke();
                    
                    ctx.fillStyle = "black";
                    ctx.font = "20px Calibri";
                    ctx.fillText("New High Score",40 * ctx.canvas.width / 320,170 * ctx.canvas.height / 480);
                    
                    ctx.font = "15px Calibri";
                    ctx.fillText("Enter your name",40 * ctx.canvas.width / 320,190 * ctx.canvas.height / 480);
                } else {
                    ctx.fillText("High Score: 9001",40 * ctx.canvas.width / 320,170 * ctx.canvas.height / 480);
                }
                
                ctx.drawImage(menuButtonImg,20 * ctx.canvas.width / 320,250 * ctx.canvas.height / 480, 140 * ctx.canvas.width / 320, 44 * ctx.canvas.height / 480);
                ctx.drawImage(restartButtonImg,160 * ctx.canvas.width / 320,250 * ctx.canvas.height / 480, 140 * ctx.canvas.width / 320, 44 * ctx.canvas.height / 480);
            }
        </script>
    </body>
</html>