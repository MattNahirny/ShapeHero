<!DOCTYPE html>
<html>
    <head>
        <title>Shape Hero</title>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
        <link type="text/css" rel="stylesheet" href="css/style.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
    </head>
    <body>
        <audio id="background_audio" autoplay="autoplay" loop="loop">
            <source src="audio/as_stars_fall.mp3" type="audio/mpeg" />
        </audio>
        <canvas id="canvas" width="320" height="480"></canvas>
        <script>
	//Shape factory returns shape objects
      function redCircle() {
          this.colour = "red";
      }
      function blueCircle() {
          this.colour = "blue";
      }
      function greenCircle() {
          this.colour = "green";
      }
      function yellowCircle() {
          this.colour = "yellow";
      }
      function redSquare() {
          this.colour = "red";
      }
      function blueSquare() {
          this.colour = "blue";
      }
      function greenSquare() {
          this.colour = "green";
      }
      function yellowSquare() {
          this.colour = "yellow";
      }
      function redTriangle() {
          this.colour = "red";
      }
      function blueTriangle() {
          this.colour = "blue";
      }
      function greenTriangle() {
          this.colour = "green";
      }
      function yellowTriangle() {
          this.colour = "yellow";
      }
      function Star() {
          this.colour = "yellow";
      }

      function ShapeFactory() { }
      ShapeFactory.prototype.createShape = function createShape(type) {
          var Shape = null;
          var Random = [redCircle, blueCircle, greenCircle, yellowCircle,
                        redSquare, blueSquare, greenSquare, yellowSquare,
                        redTriangle, blueTriangle, greenTriangle, yellowTriangle,
                        Star];

          if (type == "redCircle") {
              Shape = redCircle;
         } else if (type == "blueCircle") {
              Shape = blueCircle;
         } else if (type == "greenCircle") {
              Shape = greenCircle;
         } else if (type == "yellowCircle") {
              Shape = yellowCircle;
         } else if (type == "redSquare") {
              Shape = redSquare;
         } else if (type == "blueSquare") {
              Shape = blueSquare;
         } else if (type == "greenSquare") {
              Shape = greenSquare;
         } else if (type == "yellowSquare") {
              Shape = yellowSquare;
         } else if (type == "redTriangle") {
              Shape = redTriangle;
         } else if (type == "blueTriangle") {
              Shape = blueTriangle;
         } else if (type == "greenTriangle") {
              Shape = greenTriangle;
         } else if (type == "yellowTriangle") {
              Shape = yellowTriangle;
         } else if (type == "Star") {
              Shape = Star;
         } else if (type == "random") {
              Shape = Random[Math.floor(Math.random()*13)];
              }

          return new Shape();
      }
            function Shape(x, y, w, h, fill) {
                // This is a very simple and unsafe constructor. All we're doing is checking if the values exist.
                // "x || 0" just means "if there is a value for x, use that. Otherwise use 0."
                // But we aren't checking anything else! We could put "Lalala" for the value of x 
                this.x = x || 0;
                this.y = y || 0;
                this.w = w || 1;
                this.h = h || 1;
                this.fill = fill || '#AAAAAA';
            }

            // Draws this shape to a given context
            Shape.prototype.draw = function(ctx) {
                ctx.fillStyle = this.fill;
                ctx.fillRect(this.x, this.y, this.w, this.h);
            }
            
            Shape.prototype.update = function() {
                if(this.y <= 540) {
                    this.y += 5;
                } else {
                    this.y = -60;
                }
            }

            // Determine if a point is inside the shape's bounds
            Shape.prototype.contains = function(mx, my) {
                // All we have to do is make sure the Mouse X,Y fall in the area between
                // the shape's X and (X + Width) and its Y and (Y + Height)
                return  (this.x <= mx) && (this.x + this.w >= mx) &&
                        (this.y <= my) && (this.y + this.h >= my);
            }

            function CanvasState(canvas) {
                // **** First some setup! ****

                this.canvas = canvas;
                this.width = canvas.width;
                this.height = canvas.height;
                this.ctx = canvas.getContext('2d');
                // This complicates things a little but but fixes mouse co-ordinate problems
                // when there's a border or padding. See getMouse for more detail
                var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;
                if (document.defaultView && document.defaultView.getComputedStyle) {
                    this.stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingLeft'], 10)      || 0;
                    this.stylePaddingTop  = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingTop'], 10)       || 0;
                    this.styleBorderLeft  = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderLeftWidth'], 10)  || 0;
                    this.styleBorderTop   = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderTopWidth'], 10)   || 0;
                }
                // Some pages have fixed-position bars (like the stumbleupon bar) at the top or left of the page
                // They will mess up mouse coordinates and this fixes that
                var html = document.body.parentNode;
                this.htmlTop = html.offsetTop;
                this.htmlLeft = html.offsetLeft;

                // **** Keep track of state! ****

                this.valid = false; // when set to false, the canvas will redraw everything
                this.shapes = [];  // the collection of things to be drawn
                this.dragging = false; // Keep track of when we are dragging
                // the current selected object. In the future we could turn this into an array for multiple selection
                this.selection = null;
                this.dragoffx = 0; // See mousedown and mousemove events for explanation
                this.dragoffy = 0;
              
                // **** Then events! ****

                // This is an example of a closure!
                // Right here "this" means the CanvasState. But we are making events on the Canvas itself,
                // and when the events are fired on the canvas the variable "this" is going to mean the canvas!
                // Since we still want to use this particular CanvasState in the events we have to save a reference to it.
                // This is our reference!
                var myState = this;

                //fixes a problem where double clicking causes text to get selected on the canvas
                canvas.addEventListener('selectstart', function(e) { e.preventDefault(); return false; }, false);
                // Up, down, and move are for dragging
                canvas.addEventListener('mousedown', function(e) {
                    var mouse = myState.getMouse(e);
                    var mx = mouse.x;
                    var my = mouse.y;
                    var shapes = myState.shapes;
                    var l = shapes.length;
                    for (var i = l-1; i >= 0; i--) {
                        if (shapes[i].contains(mx, my)) {
                            var mySel = shapes[i];
                            // Keep track of where in the object we clicked
                            // so we can move it smoothly (see mousemove)
                            myState.dragoffx = mx - mySel.x;
                            myState.dragoffy = my - mySel.y;
                            myState.dragging = true;
                            myState.selection = mySel;
                            myState.valid = false;
                            window.count++;
                            return;
                        }
                    }
                    // havent returned means we have failed to select anything.
                    // If there was an object selected, we deselect it
                    if (myState.selection) {
                        myState.selection = null;
                        myState.valid = false; // Need to clear the old selection border
                    }
                }, true);
              
                canvas.addEventListener('mouseup', function(e) {
                    myState.dragging = false;
                }, true);

                // **** Options! ****

                this.selectionColor = '#CC0000';
                this.selectionWidth = 2;  
                this.interval = 30;
                setInterval(function() { myState.draw(); }, myState.interval);
            }

            CanvasState.prototype.addShape = function(shape) {
                this.shapes.push(shape);
                this.valid = false;
            }

            CanvasState.prototype.clear = function() {
                this.ctx.clearRect(0, 0, this.width, this.height);
            }

            // While draw is called as often as the INTERVAL variable demands,
            // It only ever does something if the canvas gets invalidated by our code
            CanvasState.prototype.draw = function() {
                // if our state is invalid, redraw and validate!
                if (!this.valid) {
                    var ctx = this.ctx;
                    var shapes = this.shapes;
                    this.clear();
                    
                    // ** Add stuff you want drawn in the background all the time here **
                    
                    //ctx.rect(0,0,320,480);
                    //ctx.fillStyle="white";
                    //ctx.fill();
                    
                    var backgroundImg = new Image;
                    backgroundImg.src = "img/StarBackground.png";
                    ctx.drawImage(backgroundImg,0,0);
                    
                    ctx.strokeStyle="grey";
                    ctx.beginPath();
                    ctx.moveTo(64,0);
                    ctx.lineTo(64,480);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(128,0);
                    ctx.lineTo(128,480);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(192,0);
                    ctx.lineTo(192,480);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(256,0);
                    ctx.lineTo(256,480);
                    ctx.stroke();
                    
                    // draw all shapes
                    var l = shapes.length;
                    for (var i = 0; i < l; i++) {
                      var shape = shapes[i];
                      // We can skip the drawing of elements that have moved off the screen:
                      if (shape.x > this.width || shape.y > this.height ||
                          shape.x + shape.w < 0 || shape.y + shape.h < 0) continue;
                      shapes[i].draw(ctx);
                    }
                    
                    // draw selection
                    // right now this is just a stroke along the edge of the selected Shape
                    if (this.selection != null) {
                      ctx.strokeStyle = this.selectionColor;
                      ctx.lineWidth = this.selectionWidth;
                      var mySel = this.selection;
                      ctx.strokeRect(mySel.x,mySel.y,mySel.w,mySel.h);
                    }
                    
                    //update
                    for (var i = 0; i < l; i++) {
                      var shape = shapes[i];
                      shapes[i].update();
                    }
                    
                    // ** Add stuff you want drawn on top all the time here **
                    
                    ctx.rect(0,0,320,35);
                    ctx.fillStyle="white";
                    ctx.fill();
                    
                    ctx.strokeStyle="black";
                    ctx.beginPath();
                    ctx.moveTo(0,35);
                    ctx.lineTo(320,35);
                    ctx.stroke();
                    
                    ctx.fillStyle = "black";
                    ctx.font = "30px Comic Sans MS";
                    ctx.fillText("Score: " + window.count,0,30);
                    
                    var pauseButtonImg = new Image;
                    pauseButtonImg.src = "img/pause.png";
                    ctx.drawImage(pauseButtonImg,285,0);
                    
                    ctx.rect(0,445,320,480);
                    ctx.fillStyle="white";
                    ctx.fill();
                    
                    ctx.strokeStyle="black";
                    ctx.beginPath();
                    ctx.moveTo(0,445);
                    ctx.lineTo(320,445);
                    ctx.stroke();
                    
                    ctx.fillStyle = "black";
                    ctx.font = "30px Comic Sans MS";
                    ctx.fillText("Rules: ",0,475);
                    
                    if(paused === true) {
                        pauseScreen(ctx);
                    }
                    
                    this.valid = false;
                }
            }

            // Creates an object with x and y defined, set to the mouse position relative to the state's canvas
            // If you wanna be super-correct this can be tricky, we have to worry about padding and borders
            CanvasState.prototype.getMouse = function(e) {
                var element = this.canvas, offsetX = 0, offsetY = 0, mx, my;

                // Compute the total offset
                if (element.offsetParent !== undefined) {
                    do {
                        offsetX += element.offsetLeft;
                        offsetY += element.offsetTop;
                    } while ((element = element.offsetParent));
                }

                // Add padding and border style widths to offset
                // Also add the <html> offsets in case there's a position:fixed bar
                offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;
                offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;

                mx = e.pageX - offsetX;
                my = e.pageY - offsetY;

                // We return a simple javascript object (a hash) with x and y defined
                return {x: mx, y: my};
            }

            // If you dont want to use <body onLoad='init()'>
            // You could uncomment this init() reference and place the script reference inside the body tag
            //init();

            function init() {
                window.count = 0;
                var s = new CanvasState(document.getElementById('canvas'));
                s.addShape(new Shape(4,-60,56,56, "red")); // The default is gray
                s.addShape(new Shape(68,-60,56,56, "blue"));
                // Lets make some partially transparent
                s.addShape(new Shape(132,-60,56,56, "green"));
                s.addShape(new Shape(196,-60,56,56, "yellow"));
                s.addShape(new Shape(260,-60,56,56, "orange"));
            }
            
            init();
            // Now go make something amazing!
            
            //Pause menu drawing
            function pauseScreen(ctx) {
                ctx.rect(0,35,320,410);
                ctx.fillStyle="rgba(0,0,0,.5)";
                ctx.fill();
                
                ctx.beginPath();
                ctx.lineWidth="4";
                ctx.strokeStyle="black";
                ctx.rect(22,70,276,190);
                ctx.stroke();
                ctx.fillStyle="white";
                ctx.fill();
                
                ctx.fillStyle = "black";
                ctx.font = "20px Comic Sans MS";
                ctx.fillText("Current Rule: ",25,90);
                
                ctx.beginPath();
                ctx.lineWidth="2";
                ctx.moveTo(30,165);
                ctx.lineTo(290,165);
                ctx.stroke();
                
                ctx.fillText("Background Music",70,195);
                ctx.fillText("Sound Effects",70,235);
                
                var speakerImg = new Image;
                speakerImg.src = "img/speaker.png";
                
                var muteImg = new Image;
                muteImg.src = "img/mute.png";
                
                ctx.drawImage(speakerImg,30,170);
                ctx.drawImage(muteImg,30,210);
                
                var menuButtonImg = new Image;
                menuButtonImg.src = "img/mainmenu.png";
                ctx.drawImage(menuButtonImg,20,250);
                
                var restartButtonImg = new Image;
                restartButtonImg.src = "img/restart.png";
                ctx.drawImage(restartButtonImg,160,250);
                
                var closeButtonImg = new Image;
                closeButtonImg.src = "img/close.png";
                ctx.drawImage(closeButtonImg,280,60);
            }
            
            //BGM toggle variable and function
            var bgm = document.getElementById('background_audio');
            function toggleBGM() { 
                bgm.muted = !bgm.muted;
            }
            
            //SFX toggle function, don't play sounds if false.
            var sfx = true;
            function toggleSFX() { 
                sfx = !sfx;
            }
            
            function testSFX1() {
                if(sfx === true) {
                    var error_sfx = new Audio('audio/valid.mp3');
                    error_sfx.play();
                }
            }
            
            function testSFX2() {
                if(sfx === true) {
                    var error_sfx = new Audio('audio/error.mp3');
                    error_sfx.play();
                }
            }
            
            //Pause menu toggle
            var paused = false;
            function pause() {
                paused = !paused;
            }
        </script>
        <br /><button onclick="pause()" type="button">Pause Menu</button>
        <br /><button onclick="toggleBGM()" type="button">Toggle BGM</button>
        <br /><button onclick="toggleSFX()" type="button">Toggle SFX</button>
        <br /><button onclick="testSFX1()" type="button">Test SFX 1</button>
        <br /><button onclick="testSFX2()" type="button">Test SFX 2</button>
    </body>
</html>